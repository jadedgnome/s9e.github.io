<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>s9e\TextFormatter &bull; Demo</title>
	<base href="http://s9e.github.io/TextFormatter/demo.html" />
	<style type="text/css">
		#preview
		{
			font-family: sans;
			padding: 5px;
			background-color: #f8f8f8;
			border: dashed 1px #ddd;
			border-radius: 5px;
		}

		code
		{
			padding: 2px;
			background-color: #fff;
			border-radius: 3px;
			border: solid 1px #ddd;
		}
	</style>

</head>
<body>
	<div style="float:left;width:80%;max-width:800px">
		<form>
			<textarea style="width:99%" rows="15">[float=right][youtube]http://www.youtube.com/watch?v=QH2-TGUlwu4[/youtube][/float]

This is a demo of the JavaScript port of [url=https://github.com/s9e/TextFormatter/tree/master/src/ title="s9e\TextFormatter at GitHub.com"]s9e\TextFormatter[/url].

The following plugins have been enabled:

[list]
  [*][b]Autolink[/b] --- loose URLs such as http://github.com are automatically turned into links
  [*][b]BBCodes[/b]
  [list=circle]
    [*][b]bold[/b], [i]italic[/i], [u]underline[/u], [s]strikethrough[/s],
    [*][color=#f05]co[/color][color=#2f2]lo[/color][color=#02f]r,[/color]
    [*][C][URL][/C], [C:123][C][/C:123], [C][YOUTUBE][/C], [C][FLOAT][/C], and [C][LIST][/C]
    [*][C][CODE][/C] with real-time syntax highlighting via [url=http://softwaremaniacs.org/soft/highlight/en/]Highlight.js[/url]
	[code]$who = "world";
printf("Hello %s\n", $who);[/code]
  [/list]
  [*][b]Censor[/b] --- the word "apple" is censored and automatically replaced with "banana"
  [*][b]Emoticons[/b] --- one emoticon :) has been added
  [*][b]FancyPants[/b] --- some typography is enhanced, e.g. (c) (tm) and "quotes"
  [*][b]Generic[/b] --- the Generic plugin provides a way to perform generic regexp-based replacements that are HTML-safe. Here, text that matches [C]/#(?<tag>[a-z0-9]+)/i[/C] is replaced with the template [C]<a href="https://twitter.com/#!/search/%23{@tag}"><xsl:apply-templates/></a>[/C] -- For example: #PHP, #fml
  [*][b]HTMLElements[/b] --- [C]<a>[/C] and [C]<b>[/C] tags are allowed, with two whitelisted attributes for [C]<a>[/C]: [C]href[/C] and [C]title[/C]. Example: <a href="https://github.com" title="GitHub - Social Coding"><b>GitHub</b></a>
  [*][b]HTMLEntities[/b] --- HTML entities such as &amp;hearts; are decoded
[/list]

The parser/renderer used on this page page has been generated by [url=https://github.com/s9e/TextFormatter/blob/master/scripts/generateLiveDemo.php]this script[/url]. It's been minified with Google Closure Compiler to 102.0 KB (27.3 KB compressed)</textarea>
		</form>
	</div>

	<div style="float:left;">
		<form><input type="checkbox" id="Autolink" checked="checked" onchange="toggle(this)"><label for="Autolink">&nbsp;Autolink</label><br><input type="checkbox" id="BBCodes" checked="checked" onchange="toggle(this)"><label for="BBCodes">&nbsp;BBCodes</label><br><input type="checkbox" id="Censor" checked="checked" onchange="toggle(this)"><label for="Censor">&nbsp;Censor</label><br><input type="checkbox" id="Emoticons" checked="checked" onchange="toggle(this)"><label for="Emoticons">&nbsp;Emoticons</label><br><input type="checkbox" id="FancyPants" checked="checked" onchange="toggle(this)"><label for="FancyPants">&nbsp;FancyPants</label><br><input type="checkbox" id="Generic" checked="checked" onchange="toggle(this)"><label for="Generic">&nbsp;Generic</label><br><input type="checkbox" id="HTMLElements" checked="checked" onchange="toggle(this)"><label for="HTMLElements">&nbsp;HTMLElements</label><br><input type="checkbox" id="HTMLEntities" checked="checked" onchange="toggle(this)"><label for="HTMLEntities">&nbsp;HTMLEntities</label><br><input type="checkbox" id="MediaEmbed" checked="checked" onchange="toggle(this)"><label for="MediaEmbed">&nbsp;MediaEmbed</label></form>
	</div>

	<div style="clear:both"></div>

	<div id="preview"></div>

	<script type="text/javascript">/** @const */ var HINT={};
/** @const */ HINT.attributeGenerator=0;
/** @const */ HINT.attributeDefaultValue=0;
/** @const */ HINT.closeAncestor=0;
/** @const */ HINT.closeParent=1;
/** @const */ HINT.fosterParent=0;
/** @const */ HINT.postProcessing=1;
/** @const */ HINT.regexpLimitActionAbort=0;
/** @const */ HINT.regexpLimitActionIgnore=0;
/** @const */ HINT.regexpLimitActionWarn=1;
/** @const */ HINT.requireAncestor=0;
/** @const */ HINT.RULE_AUTO_CLOSE=1;
/** @const */ HINT.RULE_AUTO_REOPEN=1;
/** @const */ HINT.RULE_BREAK_PARAGRAPH=0;
/** @const */ HINT.RULE_CREATE_PARAGRAPHS=0;
/** @const */ HINT.RULE_DISABLE_AUTO_BR=1;
/** @const */ HINT.RULE_ENABLE_AUTO_BR=1;
/** @const */ HINT.RULE_IGNORE_TAGS=1;
/** @const */ HINT.RULE_IGNORE_TEXT=1;
/** @const */ HINT.RULE_IS_TRANSPARENT=1;
/** @const */ HINT.RULE_PREVENT_BR=1;
/** @const */ HINT.RULE_SUSPEND_AUTO_BR=1;
/** @const */ HINT.RULE_TRIM_WHITESPACE=1;
/**
* @param  {!string} str
* @return {!string}
*/
function html_entity_decode(str)
{
	var b = document.createElement('b');

	// We escape left brackets so that we don't inadvertently evaluate some nasty HTML such as
	// <img src=... onload=evil() />
	b.innerHTML = str.replace(/</g, '&lt;');

	return b.textContent;
}

/**
* @param  {!string} str
* @return {!string}
*/
function htmlspecialchars_compat(str)
{
	var t = {
		'<' : '&lt;',
		'>' : '&gt;',
		'&' : '&amp;',
		'"' : '&quot;'
	};
	return str.replace(
		/[<>&"]/g,
		/**
		* @param {!string} c
		*/
		function(c)
		{
			return t[c];
		}
	);
}

/**
* @param  {!string} str
* @return {!string}
*/
function htmlspecialchars_noquotes(str)
{
	var t = {
		'<' : '&lt;',
		'>' : '&gt;',
		'&' : '&amp;'
	};
	return str.replace(
		/[<>&]/g,
		/**
		* @param {!string} c
		*/
		function(c)
		{
			return t[c];
		}
	);
}

/**
* @return {!boolean}
*/
function returnFalse()
{
	return false;
}
/**
* @param  {!string} str
* @return {!string}
*/
function rawurlencode(str)
{
	return encodeURIComponent(str).replace(
		/[!'()*]/g,
		/**
		* @param {!string} c
		*/
		function(c)
		{
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		}
	);
}

/**
* IMPORTANT NOTE: those filters are only meant to catch bad input and honest mistakes. They don't
*                 match their PHP equivalent exactly and may let unwanted values through. Their
*                 result should always be checked by PHP filters
*
* @const
*/
var BuiltInFilters =
{
	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterAlnum: function(attrValue)
	{
		return /^[0-9A-Za-z]+$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterColor: function(attrValue)
	{
		return /^(?:#[0-9a-f]{3,6}|rgb\(\d{1,3}, *\d{1,3}, *\d{1,3}\)|[a-z]+)$/i.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterEmail: function(attrValue)
	{
		return /^[-\w.+]+@[-\w.]+$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterFloat: function(attrValue)
	{
		return /^(?:0|-?[1-9]\d*)(?:\.\d+)?(?:e[1-9]\d*)?$/i.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*}        attrValue Original value
	* @param  {!Object}  map       Hash map
	* @param  {!boolean} strict    Whether this map is strict (values with no match are invalid)
	* @return {*}                  Filtered value, or FALSE if invalid
	*/
	filterHashmap: function(attrValue, map, strict)
	{
		if (attrValue in map)
		{
			return map[attrValue];
		}

		return (strict) ? false : attrValue;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterIdentifier: function(attrValue)
	{
		return /^[-\w]+$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterInt: function(attrValue)
	{
		return /^(?:0|-?[1-9]\d*)$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterIp: function(attrValue)
	{
		if (/^[\d.]+$/.test(attrValue))
		{
			return BuiltInFilters.filterIpv4(attrValue);
		}

		if (/^[\da-f:]+$/i.test(attrValue))
		{
			return BuiltInFilters.filterIpv6(attrValue);
		}

		return false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterIpport: function(attrValue)
	{
		var m, ip;

		if (m = /^\[([\da-f:]+)(\]:[1-9]\d*)$/i.exec(attrValue))
		{
			ip = BuiltInFilters.filterIpv6(m[1]);

			if (ip === false)
			{
				return false;
			}

			return '[' + ip + m[2];
		}

		if (m = /^([\d.]+)(:[1-9]\d*)$/.exec(attrValue))
		{
			ip = BuiltInFilters.filterIpv4(m[1]);

			if (ip === false)
			{
				return false;
			}

			return ip + m[2];
		}

		return false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterIpv4: function(attrValue)
	{
		if (!/^\d+\.\d+\.\d+\.\d+$/.test(attrValue))
		{
			return false;
		}

		var i = 4, p = attrValue.split('.');
		while (--i >= 0)
		{
			// NOTE: ext/filter doesn't support octal notation
			if (p[i].charAt(0) === '0' || p[i] > 255)
			{
				return false;
			}
		}

		return attrValue;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterIpv6: function(attrValue)
	{
		return /^(\d*:){2,7}\d+(?:\.\d+\.\d+\.\d+)?$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @param  {!Array.<!Array>}  map
	* @return {*}
	*/
	filterMap: function(attrValue, map)
	{
		var i = -1, cnt = map.length;
		while (++i < cnt)
		{
			if (map[i][0].test(attrValue))
			{
				return map[i][1];
			}
		}

		return attrValue;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterNumber: function(attrValue)
	{
		return /^\d+$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*}       attrValue
	* @param  {!number} min
	* @param  {!number} max
	* @param  {Logger}  logger
	* @return {!number|boolean}
	*/
	filterRange: function(attrValue, min, max, logger)
	{
		if (!/^(?:0|-?[1-9]\d*)$/.test(attrValue))
		{
			return false;
		}

		attrValue = parseInt(attrValue, 10);

		if (attrValue < min)
		{
			if (logger)
			{
				logger.warn(
					'Value outside of range, adjusted up to min value',
					{
						'attrValue' : attrValue,
						'min'       : min,
						'max'       : max
					}
				);
			}

			return min;
		}

		if (attrValue > max)
		{
			if (logger)
			{
				logger.warn(
					'Value outside of range, adjusted down to max value',
					{
						'attrValue' : attrValue,
						'min'       : min,
						'max'       : max
					}
				);
			}

			return max;
		}

		return attrValue;
	},

	/**
	* @param  {*} attrValue
	* @param  {!RegExp} regexp
	* @return {*}
	*/
	filterRegexp: function(attrValue, regexp)
	{
		return regexp.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterSimpletext: function(attrValue)
	{
		return /^[-\w+., ]+$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @return {*}
	*/
	filterUint: function(attrValue)
	{
		return /^(?:0|[1-9]\d*)$/.test(attrValue) ? attrValue : false;
	},

	/**
	* @param  {*} attrValue
	* @param  {!Object} urlConfig
	* @param  {Logger} logger
	* @return {*}
	*/
	filterUrl: function(attrValue, urlConfig, logger)
	{
		/**
		* Trim the URL to conform with HTML5 then parse it
		* @link http://dev.w3.org/html5/spec/links.html#attr-hyperlink-href
		*/
		var p = BuiltInFilters.parseUrl(attrValue.replace(/^\s+/, '').replace(/\s+$/, ''));

		// This is the reconstructed URL
		var url = '';

		// Start with the scheme
		if (p.scheme !== '')
		{
			if (!urlConfig.allowedSchemes.test(p.scheme))
			{
				if (logger)
				{
					logger.err(
						'URL scheme is not allowed',
						{'attrValue': attrValue, 'scheme': p.scheme}
					);
				}

				return false;
			}

			url += p.scheme + ':';
		}

		// Add the host if applicable
		if (p.host === '')
		{
			// Allow the file: scheme to not have a host and ensure it starts with slashes
			if (p.scheme === 'file')
			{
				url += '//';
			}
			// Reject malformed URLs such as http:///example.org but allow schemeless paths
			else if (p.scheme !== '')
			{
				return false;
			}
		}
		else
		{
			url += '//';

			/**
			* Test whether the host is valid
			* @link http://tools.ietf.org/html/rfc1035#section-2.3.1
			*/
			var regexp = /^(?=[a-z])[-a-z0-9]{0,62}[a-z0-9](?:\.(?=[a-z])[-a-z0-9]{0,62}[a-z0-9])*$/i;
			if (!regexp.test(p.host))
			{
				// If the host invalid, retest as an IPv4 and IPv6 address (IPv6 in brackets)
				if (!BuiltInFilters.filterIpv4(p.host)
				 && !BuiltInFilters.filterIpv6(p.host.replace(/^\[(.*)\]$/, '$1', p.host)))
				{
					if (logger)
					{
						logger.err(
							'URL host is invalid',
							{'attrValue': attrValue, 'host': p.host}
						);
					}

					return false;
				}
			}

			if ((urlConfig.disallowedHosts && urlConfig.disallowedHosts.test(p.host))
			 || (urlConfig.restrictedHosts && !urlConfig.restrictedHosts.test(p.host)))
			{
				if (logger)
				{
					logger.err(
						'URL host is not allowed',
						{'attrValue': attrValue, 'host': p.host}
					);
				}

				return false;
			}

			// Add the credentials if applicable
			if (p.user !== '')
			{
				// Reencode the credentials in case there are invalid chars in them, or suspicious
				// characters such as : or @ that could confuse a browser into connecting to the
				// wrong host (or at least, to a host that is different than the one we thought)
				url += rawurlencode(decodeURIComponent(p.user));

				if (p.pass !== '')
				{
					url += ':' + rawurlencode(decodeURIComponent(p.pass));
				}

				url += '@';
			}

			url += p.host;

			// Append the port number (note that as per the regexp it can only contain digits)
			if (p.port !== '')
			{
				url += ':' + p.port;
			}
		}

		// Build the path, including the query and fragment parts
		var path = p.path;
		if (p.query !== '')
		{
			path += '?' + p.query;
		}
		if (p.fragment !== '')
		{
			path += '#' + p.fragment;
		}

		/**
		* "For consistency, URI producers and normalizers should use uppercase hexadecimal digits
		* for all percent- encodings."
		*
		* @link http://tools.ietf.org/html/rfc3986#section-2.1
		*/
		path = path.replace(
			/%.?[a-f]/,
			function (m)
			{
				return m[0].toUpperCase();
			},
			path
		);

		// Append the sanitized path to the URL
		url += BuiltInFilters.sanitizeUrl(path);

		// Replace the first colon if there's no scheme and it could potentially be interpreted as
		// the scheme separator
		if (!p.scheme)
		{
			url = url.replace(/^([^\/]*):/, '$1%3A', url);
		}

		return url;
	},

	/**
	* Parse a URL and return its components
	*
	* Similar to PHP's own parse_url() except that all parts are always returned
	*
	* @param  {!string} url Original URL
	* @return {!Object}
	*/
	parseUrl: function(url)
	{
		var regexp = /^(?:([a-z][-+.\w]*):)?(?:\/\/(?:([^:\/?#]*)(?::([^\/?#]*)?)?@)?(?:(\[[a-f\d:]+\]|[^:\/?#]+)(?::(\d*))?)?(?![^\/?#]))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?$/i;

		// NOTE: this regexp always matches because of the last three captures
		var m = regexp.exec(url);

		var parts = {
			scheme   : (m[1] > '') ? m[1] : '',
			user     : (m[2] > '') ? m[2] : '',
			pass     : (m[3] > '') ? m[3] : '',
			host     : (m[4] > '') ? m[4] : '',
			port     : (m[5] > '') ? m[5] : '',
			path     : (m[6] > '') ? m[6] : '',
			query    : (m[7] > '') ? m[7] : '',
			fragment : (m[8] > '') ? m[8] : ''
		};

		/**
		* @link http://tools.ietf.org/html/rfc3986#section-3.1
		*
		* 'An implementation should accept uppercase letters as equivalent to lowercase in
		* scheme names (e.g., allow "HTTP" as well as "http") for the sake of robustness but
		* should only produce lowercase scheme names for consistency.'
		*/
		parts.scheme = parts.scheme.toLowerCase();

		/**
		* Normalize the domain label separators and remove trailing dots
		* @link http://url.spec.whatwg.org/#domain-label-separators
		*/
		parts.host = parts.host.replace(/[\u3002\uff0e\uff61]/g, '.').replace(/\.+$/g, '');

		// Test whether host has non-ASCII characters and punycode it if possible
		if (/[^\x00-\x7F]/.test(parts.host) && punycode)
		{
			parts.host = punycode.toASCII(parts.host);
		}

		return parts;
	},

	/**
	* Sanitize a URL for safe use regardless of context
	*
	* This method URL-encodes some sensitive characters in case someone would want to use the URL in
	* some JavaScript thingy, or in CSS. We also encode characters that are not allowed in the path
	* of a URL as defined in RFC 3986 appendix A, including percent signs that are not immediately
	* followed by two hex digits.
	*
	* " and ' to prevent breaking out of quotes (JavaScript or otherwise)
	* ( and ) to prevent the use of functions in JavaScript (eval()) or CSS (expression())
	* < and > to prevent breaking out of <script>
	* \r and \n because they're illegal in JavaScript
	* [ and ] because the W3 validator rejects them and they "should" be escaped as per RFC 3986
	* Non-ASCII characters as per RFC 3986
	* Control codes and spaces, as per RFC 3986
	*
	* @link http://sla.ckers.org/forum/read.php?2,51478
	* @link http://timelessrepo.com/json-isnt-a-javascript-subset
	* @link http://www.ietf.org/rfc/rfc3986.txt
	* @link http://stackoverflow.com/a/1547922
	* @link http://tools.ietf.org/html/rfc3986#appendix-A
	*
	* @param  {!string} url Original URL
	* @return {!string}     Sanitized URL
	*/
	sanitizeUrl: function(url)
	{
		return url.replace(/[^\u0020-\u007E]+/g, encodeURIComponent).replace(/%(?![0-9A-Fa-f]{2})|[^!#-&*-;=?-Z_a-z]/g, escape);
	}
}
/**@constructor*/function Logger(){}Logger.prototype={add:function(type, msg, context){},clear:function(){},setAttribute:function(attrName){},setTag:function(tag){},unsetAttribute:function(){},unsetTag:function(){},debug:function(msg, context){},err:function(msg, context){},info:function(msg, context){},warn:function(msg, context){}}
/**
* @constructor
*
* @param {!number} type Tag's type
* @param {!string} name Name of the tag
* @param {!number} pos  Position of the tag in the text
* @param {!number} len  Length of text consumed by the tag
*/
function Tag(type, name, pos, len)
{
	this.type = type;
	this.name = name;
	this.pos  = pos;
	this.len  = len;

	this.attributes = {};
	this.cascade    = [];

	// Invalidate this tag now if any value is not a number, they could wreck
	// havoc in other parts of the program
	if (isNaN(type + pos + len))
	{
		this.invalidate();
	}
}

/** @const */
Tag.START_TAG = 1;

/** @const */
Tag.END_TAG = 2;

/** @const */
Tag.SELF_CLOSING_TAG = 3;

/**
* @type {!Object} Dictionary of attributes
*/
Tag.prototype.attributes;

/**
* @type {!Array.<!Tag>} List of tags that are invalidated when this tag is invalidated
*/
Tag.prototype.cascade;

/**
* @type {Tag} End tag that unconditionally ends this start tag
*/
Tag.prototype.endTag;

/**
* @type {!boolean} Whether this tag is be invalid
*/
Tag.prototype.invalid = false;

/**
* @type {!number} Length of text consumed by this tag
*/
Tag.prototype.len;

/**
* @type {!string} Name of this tag
*/
Tag.prototype.name;

/**
* @type {!number} Position of this tag in the text
*/
Tag.prototype.pos;

/**
* @type {!number} Tiebreaker used when sorting identical tags
*/
Tag.prototype.sortPriority = 0;

/**
* @type {Tag} Start tag that is unconditionally closed this end tag
*/
Tag.prototype.startTag;

/**
* @type {!number} Tag type
*/
Tag.prototype.type;

/**
* Add a set of flags to this tag's
*
* @param {!number} flags
*/
Tag.prototype.addFlags = function(flags)
{
	this.flags |= flags;
};

/**
* Set given tag to be invalidated if this tag is invalidated
*
* @param {!Tag} tag
*/
Tag.prototype.cascadeInvalidationTo = function(tag)
{
	this.cascade.push(tag);

	// If this tag is already invalid, cascade it now
	if (this.invalid)
	{
		tag.invalidate();
	}
};

/**
* Invalidate this tag, as well as tags bound to this tag
*/
Tag.prototype.invalidate = function()
{
	// If this tag is already invalid, we can return now. This prevent infinite loops
	if (this.invalid)
	{
		return;
	}

	this.invalid = true;

	this.cascade.forEach(
		/**
		* @param {!Tag} tag
		*/
		function(tag)
		{
			tag.invalidate();
		}
	);
}

/**
* Pair this tag with given tag
*
* @param {!Tag} tag
*/
Tag.prototype.pairWith = function(tag)
{
	if (this.name === tag.name)
	{
		if (this.type === Tag.START_TAG
		 && tag.type  === Tag.END_TAG
		 && tag.pos   >=  this.pos)
		{
			this.endTag  = tag;
			tag.startTag = this;
		}
		else if (this.type === Tag.END_TAG
		      && tag.type  === Tag.START_TAG
		      && tag.pos   <=  this.pos)
		{
			this.startTag = tag;
			tag.endTag    = this;
		}
	}
}

/**
* Remove a set of flags from this tag's
*
* @param {!number} flags
*/
Tag.prototype.removeFlags = function(flags)
{
	this.flags &= ~flags;
};

/**
* Set the bitfield of boolean rules that apply to this tag
*
* @param  {!number} flags Bitfield of boolean rules that apply to this tag
*/
Tag.prototype.setFlags = function(flags)
{
	this.flags = flags;
}

/**
* Set this tag's tiebreaker
*
* @param  {!number} sortPriority
*/
Tag.prototype.setSortPriority = function(sortPriority)
{
	this.sortPriority = sortPriority;
}

//==========================================================================
// Getters
//==========================================================================

/**
* Return this tag's attributes
*
* @return {!Object}
*/
Tag.prototype.getAttributes = function()
{
	var attributes = {}
	for (var attrName in this.attributes)
	{
		attributes[attrName] = this.attributes[attrName];
	}

	return attributes;
}

/**
* Return this tag's end tag
*
* @return {Tag} This tag's end tag
*/
Tag.prototype.getEndTag = function()
{
	return this.endTag;
}

/**
* Return the bitfield of boolean rules that apply to this tag
*
* @return {!number}
*/
Tag.prototype.getFlags = function()
{
	return this.flags;
}

/**
* Return the length of text consumed by this tag
*
* @return {!number}
*/
Tag.prototype.getLen = function()
{
	return this.len;
}

/**
* Return this tag's name
*
* @return {!string}
*/
Tag.prototype.getName = function()
{
	return this.name;
}

/**
* Return this tag's position
*
* @return {!number}
*/
Tag.prototype.getPos = function()
{
	return this.pos;
}

/**
* Return this tag's tiebreaker
*
* @return {!number}
*/
Tag.prototype.getSortPriority = function()
{
	return this.sortPriority;
}

/**
* Return this tag's start tag
*
* @return {Tag} This tag's start tag
*/
Tag.prototype.getStartTag = function()
{
	return this.startTag;
}

/**
* Return this tag's type
*
* @return {!number}
*/
Tag.prototype.getType = function()
{
	return this.type;
}

//==========================================================================
// Tag's status
//==========================================================================

/**
* Test whether this tag can close given start tag
*
* @param  {!Tag} startTag
* @return {!boolean}
*/
Tag.prototype.canClose = function(startTag)
{
	if (this.invalid
	 || this.name !== startTag.name
	 || startTag.type !== Tag.START_TAG
	 || this.type !== Tag.END_TAG
	 || this.pos < startTag.pos
	 || (this.startTag && this.startTag !== startTag)
	 || (startTag.endTag && startTag.endTag !== this))
	{
		return false;
	}

	return true;
}

/**
* Test whether this tag is a br tag
*
* @return {!boolean}
*/
Tag.prototype.isBrTag = function()
{
	return (this.name === 'br');
}

/**
* Test whether this tag is an end tag (self-closing tags inclusive)
*
* @return {!boolean}
*/
Tag.prototype.isEndTag = function()
{
	return !!(this.type & Tag.END_TAG);
}

/**
* Test whether this tag is an ignore tag
*
* @return {!boolean}
*/
Tag.prototype.isIgnoreTag = function()
{
	return (this.name === 'i');
}

/**
* Test whether this tag is invalid
*
* @return {!boolean}
*/
Tag.prototype.isInvalid = function()
{
	return this.invalid;
}

/**
* Test whether this tag represents a paragraph break
*
* @return {!boolean}
*/
Tag.prototype.isParagraphBreak = function()
{
	return (this.name === 'pb');
}

/**
* Test whether this tag is a self-closing tag
*
* @return {!boolean}
*/
Tag.prototype.isSelfClosingTag = function()
{
	return (this.type === Tag.SELF_CLOSING_TAG);
}

/**
* Test whether this tag is a special tag: "br", "i" or "pb"
*
* @return {!boolean}
*/
Tag.prototype.isSystemTag = function()
{
	return (this.name === 'br' || this.name === 'i' || this.name === 'pb');
}

/**
* Test whether this tag is a start tag (self-closing tags inclusive)
*
* @return {!boolean}
*/
Tag.prototype.isStartTag = function()
{
	return !!(this.type & Tag.START_TAG);
}

//==========================================================================
// Attributes handling
//==========================================================================

/**
* Return the value of given attribute
*
* @param  {!string} attrName
* @return {!string}
*/
Tag.prototype.getAttribute = function(attrName)
{
	return this.attributes[attrName];
}

/**
* Return whether given attribute is set
*
* @param  {!string} attrName
* @return {!boolean}
*/
Tag.prototype.hasAttribute = function(attrName)
{
	return (attrName in this.attributes);
}

/**
* Remove given attribute
*
* @param {!string} attrName
*/
Tag.prototype.removeAttribute = function(attrName)
{
	delete this.attributes[attrName];
}

/**
* Set the value of an attribute
*
* @param {!string} attrName  Attribute's name
* @param {*}       attrValue Attribute's value
*/
Tag.prototype.setAttribute = function(attrName, attrValue)
{
	this.attributes[attrName] = attrValue;
}

/**
* Set all of this tag's attributes at once
*
* @param {!Object} attributes
*/
Tag.prototype.setAttributes = function(attributes)
{
	this.attributes = {}

	for (var attrName in attributes)
	{
		this.attributes[attrName] = attributes[attrName];
	}
}
/**#@+
* Boolean rules bitfield
*/
/** @const */ var RULE_AUTO_CLOSE        = 1 << 0;
/** @const */ var RULE_AUTO_REOPEN       = 1 << 1;
/** @const */ var RULE_BREAK_PARAGRAPH   = 1 << 2;
/** @const */ var RULE_CREATE_PARAGRAPHS = 1 << 3;
/** @const */ var RULE_DISABLE_AUTO_BR   = 1 << 4;
/** @const */ var RULE_ENABLE_AUTO_BR    = 1 << 5;
/** @const */ var RULE_IGNORE_TAGS       = 1 << 6;
/** @const */ var RULE_IGNORE_TEXT       = 1 << 7;
/** @const */ var RULE_IS_TRANSPARENT    = 1 << 8;
/** @const */ var RULE_PREVENT_BR        = 1 << 9;
/** @const */ var RULE_SUSPEND_AUTO_BR   = 1 << 10;
/** @const */ var RULE_TRIM_WHITESPACE   = 1 << 11;
/**#@-*/

/**
* @const Bitwise disjunction of rules related to automatic line breaks
*/
var RULES_AUTO_LINEBREAKS = RULE_DISABLE_AUTO_BR | RULE_ENABLE_AUTO_BR | RULE_SUSPEND_AUTO_BR;

/**
* @const Bitwise disjunction of rules that are inherited by subcontexts
*/
var RULES_INHERITANCE = RULE_ENABLE_AUTO_BR;

/**
* @const All the characters that are considered whitespace
*/
var WHITESPACE = " \n\t";

/**
* @type {!Object.<string,!number>} Number of open tags for each tag name
*/
var cntOpen;

/**
* @type {!Object.<string,!number>} Number of times each tag has been used
*/
var cntTotal;

/**
* @type {!Object} Current context
*/
var context;

/**
* @type {!number} How hard the parser has worked on fixing bad markup so far
*/
var currentFixingCost;

/**
* @type {Tag} Current tag being processed
*/
var currentTag;

/**
* @type {!boolean} Whether the output contains "rich" tags, IOW any tag that is not <p> or <br/>
*/
var isRich;

/**
* @type {!Logger} This parser's logger
*/
var logger = new Logger;

/**
* @type {!number} How hard the parser should work on fixing bad markup
*/
var maxFixingCost = 1000;

/**
* @type {!Object} Associative array of namespace prefixes in use in document (prefixes used as key)
*/
var namespaces;

/**
* @type {!Array.<!Tag>} Stack of open tags (instances of Tag)
*/
var openTags;

/**
* @type {!string} This parser's output
*/
var output;

/**
* @type {!Object.<!Object>}
*/
var plugins={"BBCodes":{quickMatch:"[",regexp:/\[\/?([*BIS]|C(?:O(?:DE|LOR))?|FLOAT|LIST|MEDIA|QUOTE|U(?:RL)?|YOUTUBE)(?=[\] =:\/])/ig,regexpLimit:10000,regexpLimitAction:"warn",parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={bbcodes:{"B":{},"I":{},"U":{},"S":{},"URL":{contentAttributes:["url"]},"QUOTE":{defaultAttribute:"author"},"LIST":{defaultAttribute:"type"},"*":{tagName:"LI"},"C":{},"COLOR":{},"FLOAT":{},"CODE":{defaultAttribute:"lang"},"MEDIA":{contentAttributes:["url"]},"YOUTUBE":{contentAttributes:["url"],defaultAttribute:"url"}}};
					matches.forEach(function(m)
{
	var bbcodeName = m[1][0].toUpperCase();

	// BBCodes with no custom setting may not appear in the config. We only know they exist
	// because the regexp matches exact names
	var bbcodeConfig = config.bbcodes[bbcodeName] || {};

	// Use the configured tagName if available, or reuse the BBCode's name otherwise
	var tagName = bbcodeConfig.tagName || bbcodeName;

	/**
	* @type {!number} Position of the first character of current BBCode, which should be a [
	*/
	var lpos = m[0][1];

	/**
	* @type {!number} Position of the last character of current BBCode, starts as the position
	*                 of the "]", " ", "=", ":" or "/" character as per the plugin's regexp,
	*                 then advances towards the right as the BBCode is being parsed
	*/
	var rpos = lpos + m[0][0].length;

	// Check for an identifier
	//
	// Used to explicitly pair specific tags together, e.g.
	//   [code:123][code]type your code here[/code][/code:123]
	var bbcodeId;
	if (text.charAt(rpos) === ':')
	{
		// Capture the colon and the (0 or more) digits following it
		bbcodeId = /^:\d*/.exec(text.substr(rpos))[0];

		// Move past the suffix
		rpos += bbcodeId.length;
	}
	else
	{
		bbcodeId  = '';
	}

	// Test whether this is an end tag
	if (text.charAt(lpos + 1) === '/')
	{
		// Test whether the tag is properly closed and whether this tag has an identifier.
		// We skip end tags that carry an identifier because they're automatically added
		// when their start tag is processed
		if (text.charAt(rpos) === ']' && bbcodeId === '')
		{
			addEndTag(tagName, lpos, 1 + rpos - lpos);
		}

		return;
	}

	// This is a start tag, now we'll parse attributes
	var type       = Tag.START_TAG,
		attributes = {},
		wellFormed = false,
		firstPos   = rpos,
		attrName,
		attrValue,
		tag;

	// Add predefined attributes
	if (bbcodeConfig.predefinedAttributes)
	{
		for (attrName in bbcodeConfig.predefinedAttributes)
		{
			attributes[attrName] = bbcodeConfig.predefinedAttributes[attrName];
		}
	}

	while (rpos < textLen)
	{
		/** @type {!string} */
		var c = text.charAt(rpos);

		if (c === ' ')
		{
			++rpos;
			continue;
		}

		if (c === ']' || c === '/')
		{
			// We're closing this tag
			if (c === '/')
			{
				// Self-closing tag, e.g. [foo/]
				type = Tag.SELF_CLOSING_TAG;
				++rpos;

				if (rpos === textLen || text.charAt(rpos) !== ']')
				{
					// There isn't a closing bracket after the slash, e.g. [foo/
					return;
				}
			}

			// This tag is well-formed
			wellFormed = true;

			// Move past the right bracket
			++rpos;

			break;
		}

		// Capture the attribute name
		var spn = /^[-\w]*/.exec(text.substr(rpos))[0].length;

		if (spn)
		{
			if (rpos + spn >= textLen)
			{
				// The attribute name extends to the end of the text
				return;
			}

			attrName = text.substr(rpos, spn).toLowerCase();
			rpos += spn;

			if (text.charAt(rpos) !== '=')
			{
				// It's an attribute name not followed by an equal sign, ignore it
				continue;
			}
		}
		else if (c === '=' && rpos === firstPos)
		{
			// This is the default param, e.g. [quote=foo]. If there's no default attribute
			// set, we reuse the BBCode's name instead
			attrName = bbcodeConfig.defaultAttribute || bbcodeName.toLowerCase();
		}
		else
		{
			return;
		}

		// Move past the = and make sure we're not at the end of the text
		if (++rpos >= textLen)
		{
			return;
		}

		// Grab the first character after the equal sign
		c = text.charAt(rpos);

		// Test whether the value is in quotes
		if (c === '"' || c === "'")
		{
			// This is where the actual value starts
			var valuePos = rpos + 1;

			while (1)
			{
				// Move past the quote
				++rpos;

				// Look for the next quote
				rpos = text.indexOf(c, rpos);

				if (rpos < 0)
				{
					// No matching quote. Apparently that string never ends...
					return;
				}

				// Test for an odd number of backslashes before this character
				var n = 0;
				while (text.charAt(rpos - ++n) === '\\')
				{
				}

				if (n % 2)
				{
					// If n is odd, it means there's an even number of backslashes so
					// we can exit this loop
					break;
				}
			}

			// Unescape special characters ' " and \
			attrValue = text.substr(valuePos, rpos - valuePos).replace(/\\([\\'"])/g, '$1');

			// Skip past the closing quote
			++rpos;
		}
		else
		{
			// Capture everything after the equal sign up to whichever comes first:
			//  - whitespace followed by a slash and a closing bracket
			//  - a closing bracket, optionally preceded by whitespace
			//  - whitespace followed by another attribute (name followed by equal sign)
			//
			// NOTE: this is for compatibility with some forums (such as vBulletin it seems)
			//       that do not put attribute values in quotes, e.g.
			//       [quote=John Smith;123456] (quoting "John Smith" from post #123456)
			var match = /[^\]]*?(?=\s*(?: \/)?\]|\s+[-\w]+=)/.exec(text.substr(rpos));
			if (!match)
			{
				continue;
			}

			attrValue  = match[0];
			rpos  += attrValue.length;
		}

		attributes[attrName] = attrValue;
	}

	if (!wellFormed)
	{
		return;
	}

	if (type === Tag.START_TAG)
	{
		/**
		* @type {!Array} List of attributes whose value should be set to this tag's content
		*/
		var contentAttributes = [];

		// Record the names of attributes that need the content of this tag
		if (bbcodeConfig.contentAttributes)
		{
			bbcodeConfig.contentAttributes.forEach(function(attrName)
			{
				if (!(attrName in attributes))
				{
					contentAttributes.push(attrName);
				}
			});
		}

		// Test whether we need to look for this tag's end tag
		var endTag;
		if (contentAttributes.length || bbcodeId || bbcodeConfig.forceLookahead)
		{
			// Find the position of its end tag
			var match     = '[/' + bbcodeName + bbcodeId + ']',
				endTagPos = text.toUpperCase().indexOf(match, rpos);

			if (endTagPos < 0)
			{
				// We didn't find an end tag, did we *need* one?
				if (bbcodeId || bbcodeConfig.forceLookahead)
				{
					// No matching end tag, we skip this start tag
					return;
				}
			}
			else
			{
				// We found the end tag, we can use the content of this tag pair
				contentAttributes.forEach(function(attrName)
				{
					attributes[attrName] = text.substr(rpos, endTagPos - rpos);
				});

				// We create an end tag, which we will pair with this start tag
				endTag = addEndTag(tagName, endTagPos, match.length);
			}
		}

		// Create this start tag
		tag = addStartTag(tagName, lpos, rpos - lpos);

		// If an end tag was created, pair it with this start tag
		if (endTag)
		{
			tag.pairWith(endTag);
		}
	}
	else
	{
		tag = addSelfClosingTag(tagName, lpos, rpos - lpos);
	}

	// Add all attributes to the tag
	tag.setAttributes(attributes);
});
				}},"Censor":{regexp:/(?:^|\W)apple(?!\w)/gi,regexpLimit:10000,regexpLimitAction:"warn",parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={attrName:"with",tagName:"CENSOR",replacements:[[/^apple$/i,"banana"]]};
					var tagName  = config.tagName,
	attrName = config.attrName;

matches.forEach(function(m)
{
	if (config.allowed && config.allowed.test(m[0][0]))
	{
		return;
	}

	// NOTE: unlike the PCRE regexp, the JavaScript regexp can consume an extra character at the
	//       start of the match, so we have to adjust the position and length accordingly
	var offset = /^\W/.test(m[0][0]) ? 1 : 0,
		word   = m[0][0].substr(offset),
		tag    = addSelfClosingTag(tagName, m[0][1] + offset, word.length);

	// TODO: revisit loop, get Closure Compiler to optimize the block away if there's no replacements
	if (config.replacements)
	{
		for (var i = 0; i < config.replacements.length; ++i)
		{
			var regexp      = config.replacements[i][0],
				replacement = config.replacements[i][1];

			if (regexp.test(word))
			{
				tag.setAttribute(attrName, replacement);
				break;
			}
		}
	}
});
				}},"Emoticons":{quickMatch:":)",regexp:/:\)/g,regexpLimit:10000,regexpLimitAction:"warn",parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={tagName:"E"};
					matches.forEach(function(m)
{
	if (config.notAfter && m[0][1] && config.notAfter.test(text.charAt(m[0][1] - 1)))
	{
		return;
	}

	addSelfClosingTag(config.tagName, m[0][1], m[0][0].length);
});
				}},"Generic":{parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={generics:[["G60D5AB76",/#([a-z0-9]+)/ig,0,["","tag"]]]};
					config.generics.forEach(function(entry)
{
	var tagName        = entry[0],
		regexp         = entry[1],
		passthroughIdx = entry[2],
		map            = entry[3],
		m;

	// Reset the regexp
	regexp.lastIndex = 0;

	while (m = regexp.exec(text))
	{
		var startTagPos = m['index'],
			matchLen    = m[0].length,
			tag;

		if (passthroughIdx && m[passthroughIdx] !== '')
		{
			// Compute the position and length of the start tag, end tag, and the content in
			// between. m.index gives us the position of the start tag but we don't know its length.
			// We use indexOf() to locate the content part so that we know how long the start tag
			// is. It is an imperfect solution but it should work well enough in most cases.
			var contentPos  = text.indexOf(m[passthroughIdx], startTagPos),
				contentLen  = m[passthroughIdx].length,
				startTagLen = contentPos - startTagPos,
				endTagPos   = contentPos + contentLen,
				endTagLen   = matchLen - (startTagLen + contentLen);

			tag = addTagPair(
				tagName,
				startTagPos,
				startTagLen,
				endTagPos,
				endTagLen
			);
		}
		else
		{
			tag = addSelfClosingTag(tagName, startTagPos, matchLen);
		}

		map.forEach(function(attrName, i)
		{
			// NOTE: subpatterns with no name have an empty entry to preserve the array indices
			if (attrName)
			{
				tag.setAttribute(attrName, m[i]);
			}
		});
	}
});
				}},"HTMLElements":{quickMatch:"<",regexp:/<(?:\/([ab])|([ab])((?:\s+[a-z][-a-z0-9]*(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s"'=<>`]+))?)*)\s*\/?)\s*>/ig,regexpLimit:10000,regexpLimitAction:"warn",parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={prefix:"html"};
					matches.forEach(function(m)
{
	// Test whether this is an end tag
	var isEnd = (text.charAt(m[0][1] + 1) === '/');

	var pos    = m[0][1],
		len    = m[0][0].length,
		elName = m[2 - isEnd][0].toLowerCase();

	// Use the element's alias if applicable, or the  name of the element (with the
	// configured prefix) otherwise
	var tagName = (config.aliases && config.aliases[elName] && config.aliases[elName][''])
	            ? config.aliases[elName]['']
	            : config.prefix + ':' + elName;

	if (isEnd)
	{
		addEndTag(tagName, pos, len);

		return;
	}

	// Test whether it's a self-closing tag or a start tag.
	//
	// A self-closing tag will become one start tag consuming all of the text followed by a
	// 0-width end tag. Alternatively, it could be replaced by a pair of 0-width tags plus
	// an ignore tag to prevent the text in between from being output
	var tag = (m[0][0].substr(len - 2) === '/>')
			? addTagPair(tagName, pos, len, pos + len, 0)
			: addStartTag(tagName, pos, len);

	captureAttributes(tag, elName, m[3][0]);
});

/**
* Capture all attributes in given string
*
* @param  {!Tag}    tag    Target tag
* @param  {!string} elName Name of the HTML element
* @param  {!string} str    String containing the attribute declarations
*/
function captureAttributes(tag, elName, str)
{
	// Capture attributes
	var attrRegexp = /[a-z][-a-z0-9]*(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s"'=<>`]+))?/gi,
		attrName,
		attrValue,
		attrMatch;

	while (attrMatch = attrRegexp.exec(str))
	{
		pos = attrMatch[0].indexOf('=');

		/**
		* If there's no equal sign, it's a boolean attribute and we generate a value equal
		* to the attribute's name, lowercased
		*
		* @link http://www.w3.org/html/wg/drafts/html/master/single-page.html#boolean-attributes
		*/
		if (pos < 0)
		{
			pos = attrMatch[0].length;
			attrMatch[0] += '=' + attrMatch[0].toLowerCase();
		}

		// Normalize the attribute name, remove the whitespace around its value to account
		// for cases like <b title = "foo"/>
		attrName  = attrMatch[0].substr(0, pos).toLowerCase().replace(/^\s+/, '').replace('/\s+$/', '');
		attrValue = attrMatch[0].substr(1 + pos).replace(/^\s+/, '').replace('/\s+$/', '');

		// Use the attribute's alias if applicable
		if (config.aliases && config.aliases[elName] && config.aliases[elName][attrName])
		{
			attrName = config.aliases[elName][attrName];
		}

		// Remove quotes around the value
		if (/^["']/.test(attrValue))
		{
			attrValue = attrValue.substr(1, attrValue.length - 2);
		}

		tag.setAttribute(attrName, html_entity_decode(attrValue));
	}
}
				}},"Autolink":{quickMatch:":\/\/",regexp:/https?:\/\/\S(?:[^\s\[\]]*(?:\[\w*\])?)+/ig,regexpLimit:10000,regexpLimitAction:"warn",parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={attrName:"url",tagName:"URL"};
					var tagName  = config.tagName,
	attrName = config.attrName;

matches.forEach(function(m)
{
	var url = m[0][0];

	// Remove trailing punctuation and right angle brackets. We preserve right parentheses
	// if there's a balanced number of parentheses in the URL, e.g.
	//   http://en.wikipedia.org/wiki/Mars_(disambiguation)
	while (1)
	{
		// We remove some common ASCII punctuation and whitespace. We don't have access to Unicode
		// properties, so we try to cover the most common usage
		url = url.replace(/[\s!"',.<>?]+$/, '');

		if (url.substr(-1) === ')' && url.replace(/[^(]+/g, '').length < url.replace(/[^)]+/g, '').length)
		{
			url = url.substr(0, url.length - 1);
			continue;
		}
		break;
	}

	// Create a zero-width start tag right before the URL
	var startTag = addStartTag(tagName, m[0][1], 0);
	startTag.setAttribute(attrName, url);

	// Create a zero-width end tag right after the URL
	var endTag = addEndTag(tagName, m[0][1] + url.length, 0);

	// Pair the tags together
	startTag.pairWith(endTag);
});
				}},"HTMLEntities":{quickMatch:"&",regexp:/&(?:[a-z]+|#(?:[0-9]+|x[0-9a-f]+));/ig,regexpLimit:10000,regexpLimitAction:"warn",parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={attrName:"char",tagName:"HE"};
					var tagName  = config.tagName,
	attrName = config.attrName;

matches.forEach(function(m)
{
	var entity = m[0][0],
		chr    = html_entity_decode(entity);

	if (chr === entity)
	{
		// The entity was not decoded, so we assume it's not valid and we ignore it
		return;
	}

	addSelfClosingTag(tagName, m[0][1], entity.length).setAttribute(attrName, chr);
});
				}},"FancyPants":{parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={attrName:"char",tagName:"FP"};
					var hasSingleQuote = (text.indexOf("'") >= 0),
	hasDoubleQuote = (text.indexOf('"') >= 0);

// Do apostrophes ’ after a letter or at the beginning of a word or a couple of digits
if (hasSingleQuote)
{
	parseSingleQuotes(text);
}

// Do symbols found after a digit:
//  - apostrophe ’ if it's followed by an "s" as in 80's
//  - prime ′ and double prime ″
//  - multiply sign × if it's followed by an optional space and another digit
if (hasSingleQuote || hasDoubleQuote || text.indexOf('x') >= 0)
{
	parseSymbolsAfterDigits(text);
}

// Do quote pairs ‘’ and “” -- must be done separately to handle nesting
if (hasSingleQuote)
{
	parseSingleQuotePairs();
}
if (hasDoubleQuote)
{
	parseDoubleQuotePairs();
}

// Do en dash –, em dash — and ellipsis …
if (text.indexOf('...') >= 0 || text.indexOf('--')  >= 0)
{
	parseDashesAndEllipses();
}

// Do symbols ©, ® and ™
if (text.indexOf('(') >= 0)
{
	parseSymbolsInParentheses();
}

/**
* Parse dashes and ellipses
*/
function parseDashesAndEllipses()
{
	var chrs = {
		'--'  : "\u2013",
		'---' : "\u2014",
		'...' : "\u2026"
	};

	// '/---?|\\.\\.\\./S'
	var m, regexp = /---?|\.\.\./g;
	while (m = regexp.exec(text))
	{
		var pos = +m['index'],
			len = m[0].length,
			chr = chrs[m[0]];

		addSelfClosingTag(config.tagName, pos, len).setAttribute(config.attrName, chr);
	}
}

/**
* Parse pairs of double quotes
*/
function parseDoubleQuotePairs()
{
	// '/(?<![0-9\\pL])"[^"\\n]+"(?![0-9\\pL])/uS'
	parseQuotePairs('"', /(?:^|\W)".+?"(?!\w)/g, "\u201c", "\u201d");
}

/**
* Parse pairs of quotes
*
* @param {!string} q          ASCII quote character 
* @param {!RegExp} regexp     Regexp used to identify quote pairs
* @param {!string} leftQuote  Fancy replacement for left quote
* @param {!string} rightQuote Fancy replacement for right quote
*/
function parseQuotePairs(q, regexp, leftQuote, rightQuote)
{
	var m;
	while (m = regexp.exec(text))
	{
		var left  = addSelfClosingTag(config.tagName, +m['index'] + m[0].indexOf(q), 1),
			right = addSelfClosingTag(config.tagName, +m['index'] + m[0].length - 1, 1);

		left.setAttribute(config.attrName, leftQuote);
		right.setAttribute(config.attrName, rightQuote);

		// Cascade left tag's invalidation to the right so that if we skip the left quote,
		// the right quote is left untouched
		left.cascadeInvalidationTo(right);
	}
}

/**
* Parse pairs of single quotes
*/
function parseSingleQuotePairs()
{
	// "/(?<![0-9\\pL])'[^'\\n]+'(?![0-9\\pL])/uS"
	parseQuotePairs("'", /(?:^|\W)'.+?'(?!\w)/g, "\u2018", "\u2019");
}

/**
* Parse single quotes in general
*/
function parseSingleQuotes(text)
{
	// "/(?<=\\pL)'|(?<!\\S)'(?=\\pL|[0-9]{2})/uS"
	var m, regexp = /[a-z]'|(?:^|\s)'(?=[a-z]|[0-9]{2})/gi;

	while (m = regexp.exec(text))
	{
		var tag = addSelfClosingTag(config.tagName, +m['index'] + m[0].indexOf("'"), 1);
		tag.setAttribute(config.attrName, "\u2019");

		// Give this tag a worse priority than default so that quote pairs take precedence
		tag.setSortPriority(10);
	}
}

/**
* Parse symbols found after digits
*/
function parseSymbolsAfterDigits(text)
{
	// '/[0-9](?:\'s|["\']? ?x(?= ?[0-9])|["\'])/S'
	var m, regexp = /[0-9](?:'s|["']? ?x(?= ?[0-9])|["'])/g;

	while (m = regexp.exec(text))
	{
		// Test for a multiply sign at the end
		var pos = +m['index'] + m[0].length - 1;
		if (m[0].charAt(pos) === 'x')
		{
			addSelfClosingTag(config.tagName, pos, 1).setAttribute(config.attrName, "\u00d7");
		}

		// Test for a apostrophe/prime right after the digit
		var c = m[0].charAt(1);
		if (c === "'" || c === '"')
		{
			pos = +m['index'] + 1;

			var chr;
			if (m[0].substr(1, 2) === "'s")
			{
				// 80's -- use an apostrophe
				chr = "\u2019";
			}
			else
			{
				// 12' or 12" -- use a prime
				chr = (c === "'") ? "\u2032" : "\u2033";
			}

			addSelfClosingTag(config.tagName, pos, 1).setAttribute(config.attrName, chr);
		}
	}
}

/**
* Parse symbols found in parentheses such as (c)
*/
function parseSymbolsInParentheses()
{
	var chrs = {
		'(c)'  : "\u00A9",
		'(r)'  : "\u00AE",
		'(tm)' : "\u2122"
	};

	// '/\\((?:c|r|tm)\\)/i'
	var m, regexp = /\((?:c|r|tm)\)/gi;
	while (m = regexp.exec(text))
	{
		var pos = +m['index'],
			len = m[0].length,
			chr = chrs[m[0].toLowerCase()];

		addSelfClosingTag(config.tagName, pos, len).setAttribute(config.attrName, chr);
	}
}
				}},"MediaEmbed":{quickMatch:":\/\/",regexp:/\bhttps?:\/\/(?:[-.\w]+\.)?youtu(?:\.be|be\.com)\/[^["'\s]+(?!\S)/g,regexpLimit:10000,regexpLimitAction:"warn",parser:/**
				* @param {!string} text
				* @param {!Array.<Array>} matches
				*/
				function(text, matches)
				{
					/** @const */
					var config={};
					matches.forEach(function(m)
{
	var url = m[0][0],
		pos = m[0][1],
		len = url.length,
		tag = addSelfClosingTag('MEDIA', pos, len);

	tag.setAttribute('url', url);

	// Give that tag priority over other tags such as Autolink's
	tag.setSortPriority(-10);
});
				}}};

/**
* @type {!number} Position of the cursor in the original text
*/
var pos;

/**
* @type {!Object} Variables registered for use in filters
*/
var registeredVars={"urlConfig":{allowedSchemes:/^https?$/i},"mediasites":{"youtube.com":"youtube","youtu.be":"youtube"}};

/**
* @type {!Object} Root context, used at the root of the document
*/
var rootContext={allowedChildren:[0x37],allowedDescendants:[0x3F],flags:32};

/**
* @type {!Object} Tags' config
* @const
*/
var tagsConfig={"B":{filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:2},tagLimit:1000,bitNumber:0,allowedChildren:[0x33],allowedDescendants:[0x3F]},"I":{filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:2},tagLimit:1000,bitNumber:0,allowedChildren:[0x33],allowedDescendants:[0x3F]},"U":{filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:2},tagLimit:1000,bitNumber:0,allowedChildren:[0x33],allowedDescendants:[0x3F]},"S":{filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:2},tagLimit:1000,bitNumber:0,allowedChildren:[0x33],allowedDescendants:[0x3F]},"URL":{attributes:{"url":{filterChain:[cC9B15C5A],required:!0},"title":{required:!1}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:258},tagLimit:1000,bitNumber:1,allowedChildren:[0x35],allowedDescendants:[0x3D]},"QUOTE":{attributes:{"author":{required:!1}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:2048},tagLimit:1000,bitNumber:2,allowedChildren:[0x37],allowedDescendants:[0x3F]},"LIST":{attributes:{"type":{filterChain:[c9BA30EFD,c796767C5],required:!1}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:3712},tagLimit:1000,bitNumber:2,allowedChildren:[0x28],allowedDescendants:[0x3F]},"LI":{filterChain:[c2503AA6D],nestingLimit:10,rules:{closeParent:{"LI":1},flags:2048},tagLimit:1000,bitNumber:3,allowedChildren:[0x37],allowedDescendants:[0x3F]},"C":{filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:66},tagLimit:1000,bitNumber:0,allowedChildren:[0x00],allowedDescendants:[0x00]},"COLOR":{attributes:{"color":{filterChain:[c26B0971A],required:!0}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:2},tagLimit:1000,bitNumber:0,allowedChildren:[0x33],allowedDescendants:[0x3F]},"FLOAT":{attributes:{"float":{filterChain:[c6CC3304F],required:!0}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:2048},tagLimit:1000,bitNumber:2,allowedChildren:[0x37],allowedDescendants:[0x3F]},"CODE":{attributes:{"lang":{filterChain:[c59E8427B],required:!1}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:2128},tagLimit:1000,bitNumber:2,allowedChildren:[0x00],allowedDescendants:[0x00]},"CENSOR":{attributes:{"with":{required:!1}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:1601},tagLimit:1000,bitNumber:4,allowedChildren:[0x00],allowedDescendants:[0x00]},"E":{filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:1537},tagLimit:1000,bitNumber:0,allowedChildren:[0x30],allowedDescendants:[0x3F]},"G60D5AB76":{attributes:{"tag":{filterChain:[c9A7991A2],required:!0}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:258},tagLimit:1000,bitNumber:1,allowedChildren:[0x35],allowedDescendants:[0x3D]},"html:a":{attributes:{"href":{filterChain:[cC9B15C5A],required:!1},"title":{required:!1}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:258},tagLimit:1000,bitNumber:1,allowedChildren:[0x35],allowedDescendants:[0x3D]},"html:b":{filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:2},tagLimit:1000,bitNumber:0,allowedChildren:[0x33],allowedDescendants:[0x3F]},"HE":{attributes:{"char":{required:!0}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:1537},tagLimit:1000,bitNumber:4,allowedChildren:[0x30],allowedDescendants:[0x3F]},"FP":{attributes:{"char":{required:!0}},filterChain:[c2503AA6D],nestingLimit:10,rules:{flags:1537},tagLimit:1000,bitNumber:4,allowedChildren:[0x30],allowedDescendants:[0x3F]},"MEDIA":{filterChain:[c5C101E80],nestingLimit:10,rules:{flags:321},tagLimit:1000,bitNumber:5,allowedChildren:[0x00],allowedDescendants:[0x00]},"YOUTUBE":{attributes:{"url":{filterChain:[cC9B15C5A],required:!1},"id":{filterChain:[cDF0F1849],required:!0},"h":{filterChain:[c6D49533B],required:!1},"m":{filterChain:[c6D49533B],required:!1},"s":{filterChain:[c6D49533B],required:!1},"t":{filterChain:[c6D49533B],required:!1},"list":{filterChain:[cDF0F1849],required:!1}},attributePreprocessors:[["url",/youtube\.com\/(?:watch.*?v=|v\/)([-\w]+)/,["","id"]],["url",/youtu\.be\/([-\w]+)/,["","id"]],["url",/[#&?]t=(?:(?:(\d+)h)?(\d+)m(\d+)|(\d+))/,["","h","m","s","t"]],["url",/&list=([-\w]+)/,["","list"]],["url",/^([-\w]+)$/,["","id"]]],filterChain:[c0FD361FA,c2503AA6D],nestingLimit:10,rules:{flags:1601},tagLimit:1000,bitNumber:1,allowedChildren:[0x00],allowedDescendants:[0x00]}};

/**
* @type {!Array.<!Tag>} Tag storage
*/
var tagStack;

/**
* @type {!boolean} Whether the tags in the stack are sorted
*/
var tagStackIsSorted;

/**
* @type {!string} Text being parsed
*/
var text;

/**
* @type {!number} Length of the text being parsed
*/
var textLen;

/**
* @type {!number} Counter incremented everytime the parser is reset. Used to as a canary to detect
*                 whether the parser was reset during execution
*/
var uid = 0;

/**
* @type {!number} Position before which we output text verbatim, without paragraphs or linebreaks
*/
var wsPos;

//==========================================================================
// Public API
//==========================================================================

/**
* Disable a tag
*
* @param {!string} tagName Name of the tag
*/
function disableTag(tagName)
{
	if (tagsConfig[tagName])
	{
		tagsConfig[tagName].isDisabled = true;
	}
}

/**
* Enable a tag
*
* @param {!string} tagName Name of the tag
*/
function enableTag(tagName)
{
	if (tagsConfig[tagName])
	{
		tagsConfig[tagName].isDisabled = false;
	}
}

/**
* Get this parser's Logger instance
*
* @return {!Logger}
*/
function getLogger()
{
	return logger;
}

/**
* Parse a text
*
* @param  {!string} _text Text to parse
* @return {!string}       XML representation
*/
function parse(_text)
{
	// Reset the parser and save the uid
	reset(_text);
	var _uid = uid;

	// Do the heavy lifting
	executePluginParsers();
	processTags();

	// Check the uid in case a plugin or a filter reset the parser mid-execution
	if (uid !== _uid)
	{
		throw 'The parser has been reset during execution';
	}

	return output;
}

/**
* Reset the parser for a new parsing
*
* @param {!string} _text Text to be parsed
*/
function reset(_text)
{
	// Normalize CR/CRLF to LF, remove control characters that aren't allowed in XML
	_text = _text.replace(/\r\n?/g, "\n", _text);
	_text = _text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]+/g, '', _text);

	// Clear the logs
	logger.clear();

	// Initialize the rest
	currentFixingCost = 0;
	isRich     = false;
	namespaces = {};
	output     = '';
	text       = _text;
	textLen    = text.length;
	tagStack   = [];
	tagStackIsSorted = true;
	wsPos      = 0;

	// Bump the UID
	++uid;
}

/**
* Change a tag's tagLimit
*
* NOTE: the default tagLimit should generally be set during configuration instead
*
* @param {!string} tagName  The tag's name, in UPPERCASE
* @param {!number} tagLimit
*/
function setTagLimit(tagName, tagLimit)
{
	if (tagsConfig[tagName])
	{
		tagsConfig[tagName].tagLimit = tagLimit;
	}
}

/**
* Change a tag's nestingLimit
*
* NOTE: the default nestingLimit should generally be set during configuration instead
*
* @param {!string} tagName      The tag's name, in UPPERCASE
* @param {!number} nestingLimit
*/
function setNestingLimit(tagName, nestingLimit)
{
	if (tagsConfig[tagName])
	{
		tagsConfig[tagName].nestingLimit = nestingLimit;
	}
}

//==========================================================================
// Filter processing
//==========================================================================

/**
* Execute all the attribute preprocessors of given tag
*
* @private
*
* @param  {!Tag}     tag       Source tag
* @param  {!Object}  tagConfig Tag's config
* @return {!boolean}           Unconditionally TRUE
*/
function executeAttributePreprocessors(tag, tagConfig)
{
	if (tagConfig.attributePreprocessors)
	{
		tagConfig.attributePreprocessors.forEach(function(attributePreprocessor)
		{
			var attrName = attributePreprocessor[0],
				regexp   = attributePreprocessor[1],
				map      = attributePreprocessor[2];

			if (!tag.hasAttribute(attrName))
			{
				return;
			}

			var m, attrValue = tag.getAttribute(attrName);

			// If the regexp matches, we remove the source attribute then we add the
			// captured attributes
			if (m = regexp.exec(attrValue))
			{
				// Set the target attributes
				map.forEach(function(targetName, mIndex)
				{
					// Skip captures with no targets and targets with no captures (in case of
					// optional captures)
					if (targetName === '' || typeof m[mIndex] !== 'string')
					{
						return;
					}

					var targetValue = m[mIndex];

					// Attribute preprocessors cannot overwrite other attributes but they can
					// overwrite themselves
					if (targetName === attrName || !tag.hasAttribute(targetName))
					{
						tag.setAttribute(targetName, targetValue);
					}
				});
			}
		});
	}

	return true;
}

/**
* Filter the attributes of given tag
*
* @private
*
* @param  {!Tag}     tag            Tag being checked
* @param  {!Object}  tagConfig      Tag's config
* @param  {!Object}  registeredVars Vars registered for use in attribute filters
* @param  {!Logger}  logger         This parser's Logger instance
* @return {!boolean}           Whether the whole attribute set is valid
*/
function filterAttributes(tag, tagConfig, registeredVars, logger)
{
	if (!tagConfig.attributes)
	{
		tag.setAttributes({});

		return true;
	}

	var attrName, attrConfig;

	// Generate values for attributes with a generator set
	if (HINT.attributeGenerator)
	{
		for (attrName in tagConfig.attributes)
		{
			attrConfig = tagConfig.attributes[attrName];

			if (attrConfig.generator)
			{
				tag.setAttribute(attrName, attrConfig.generator(attrName));
			}
		}
	}

	// Filter and remove invalid attributes
	var attributes = tag.getAttributes();
	for (attrName in attributes)
	{
		var attrValue = attributes[attrName];

		// Test whether this attribute exists and remove it if it doesn't
		if (!tagConfig.attributes[attrName])
		{
			tag.removeAttribute(attrName);
			continue;
		}

		attrConfig = tagConfig.attributes[attrName];

		// Test whether this attribute has a filterChain
		if (!attrConfig.filterChain)
		{
			continue;
		}

		// Record the name of the attribute being filtered into the logger
		logger.setAttribute(attrName);

		for (var i = 0; i < attrConfig.filterChain.length; ++i)
		{
			// NOTE: attrValue is intentionally set as the first argument to facilitate inlining
			attrValue = attrConfig.filterChain[i](attrValue, attrName);

			if (attrValue === false)
			{
				tag.removeAttribute(attrName);
				break;
			}
		}

		// Update the attribute value if it's valid
		if (attrValue !== false)
		{
			tag.setAttribute(attrName, attrValue);
		}

		// Remove the attribute's name from the logger
		logger.unsetAttribute();
	}

	// Iterate over the attribute definitions to handle missing attributes
	for (attrName in tagConfig.attributes)
	{
		attrConfig = tagConfig.attributes[attrName];

		// Test whether this attribute is missing
		if (!tag.hasAttribute(attrName))
		{
			if (HINT.attributeDefaultValue && attrConfig.defaultValue !== undefined)
			{
				// Use the attribute's default value
				tag.setAttribute(attrName, attrConfig.defaultValue);
			}
			else if (attrConfig.required)
			{
				// This attribute is missing, has no default value and is required, which means
				// the attribute set is invalid
				return false;
			}
		}
	}

	return true;
}

/**
* Execute given tag's filterChain
*
* @param  {!Tag}     tag Tag to filter
* @return {!boolean}     Whether the tag is valid
*/
function filterTag(tag)
{
	var tagName   = tag.getName(),
		tagConfig = tagsConfig[tagName],
		isValid   = true;

	if (tagConfig.filterChain)
	{
		// Record the tag being processed into the logger it can be added to the context of
		// messages logged during the execution
		logger.setTag(tag);

		for (var i = 0; i < tagConfig.filterChain.length; ++i)
		{
			if (!tagConfig.filterChain[i](tag, tagConfig))
			{
				isValid = false;
				break;
			}
		}

		// Remove the tag from the logger
		logger.unsetTag();
	}

	return isValid;
}

//==========================================================================
// Output handling
//==========================================================================

/**
* Finalize the output by appending the rest of the unprocessed text and create the root node
*/
function finalizeOutput()
{
	var tmp;

	// Output the rest of the text and close the last paragraph
	outputText(textLen, 0, true);

	// Remove empty tag pairs, e.g. <I><U></U></I> as well as empty paragraphs
	do
	{
		tmp = output;
		output = output.replace(/<((?:\w+:)?\w+)[^>]*><\/\1>/g, '');
	}
	while (output !== tmp);

	// Merge consecutive <i> tags
	output = output.replace(/<\/i><i>/g, '', output);

	// Use a <r> root if the text is rich, or <t> for plain text (including <p></p> and <br/>)
	var tagName = (isRich) ? 'r' : 't';

	// Prepare the root node with all the namespace declarations
	tmp = '<' + tagName;
	for (var prefix in namespaces)
	{
		tmp += ' xmlns:' + prefix + '="urn:s9e:TextFormatter:' + prefix + '"';
	}

	output = tmp + '>' + output + '</' + tagName + '>';
}

/**
* Append a tag to the output
*
* @param {!Tag} tag Tag to append
*/
function outputTag(tag)
{
	isRich = true;

	var tagName    = tag.getName(),
		tagPos     = tag.getPos(),
		tagLen     = tag.getLen(),
		tagFlags   = tag.getFlags(),
		skipBefore = 0,
		skipAfter  = 0;

	if (HINT.RULE_TRIM_WHITESPACE && (tagFlags & RULE_TRIM_WHITESPACE))
	{
		skipBefore = (tag.isStartTag()) ? 2 : 1;
		skipAfter  = (tag.isEndTag())   ? 2 : 1;
	}

	// Current paragraph must end before the tag if:
	//  - the tag is a start (or self-closing) tag and it breaks paragraphs, or
	//  - the tag is an end tag (but not self-closing)
	var closeParagraph = false;
	if (tag.isStartTag())
	{
		if (HINT.RULE_BREAK_PARAGRAPH && (tagFlags & RULE_BREAK_PARAGRAPH))
		{
			closeParagraph = true;
		}
	}
	else
	{
		closeParagraph = true;
	}

	// Let the cursor catch up with this tag's position
	outputText(tagPos, skipBefore, closeParagraph);

	// Capture the text consumed by the tag
	var tagText = (tagLen)
				? htmlspecialchars_noquotes(text.substr(tagPos, tagLen))
				: '';

	// Output current tag
	if (tag.isStartTag())
	{
		// Handle paragraphs before opening the tag
		if (!HINT.RULE_BREAK_PARAGRAPH || !(tagFlags & RULE_BREAK_PARAGRAPH))
		{
			outputParagraphStart(tagPos);
		}

		// Record this tag's namespace, if applicable
		var colonPos = tagName.indexOf(':');
		if (colonPos > 0)
		{
			namespaces[tagName.substr(0, colonPos)] = 0;
		}

		// Open the start tag and add its attributes, but don't close the tag
		output += '<' + tagName;

		// We output the attributes in lexical order. Helps canonicalizing the output and could
		// prove useful someday
		var attributes = tag.getAttributes(),
			attributeNames = [];
		for (var attrName in attributes)
		{
			attributeNames.push([attrName]);
		}
		attributeNames.sort(
			function(a, b)
			{
				return (a > b) ? 1 : -1;
			}
		);
		attributeNames.forEach(
			function(attrName)
			{
				output += ' ' + attrName + '="' + htmlspecialchars_compat(attributes[attrName].toString()) + '"';
			}
		);

		if (tag.isSelfClosingTag())
		{
			if (tagLen)
			{
				output += '>' + tagText + '</' + tagName + '>';
			}
			else
			{
				output += '/>';
			}
		}
		else if (tagLen)
		{
			output += '><s>' + tagText + '</s>';
		}
		else
		{
			output += '>';
		}
	}
	else
	{
		if (tagLen)
		{
			output += '<e>' + tagText + '</e>';
		}

		output += '</' + tagName + '>';
	}

	// Move the cursor past the tag
	pos = tagPos + tagLen;

	// Skip newlines (no other whitespace) after this tag
	wsPos = pos;
	while (skipAfter && wsPos < textLen && text.charAt(wsPos) === "\n")
	{
		// Decrement the number of lines to skip
		--skipAfter;

		// Move the cursor past the newline
		++wsPos;
	}
}

/**
* Output the text between the cursor's position (included) and given position (not included)
*
* @param  {!number}  catchupPos     Position we're catching up to
* @param  {!number}  maxLines       Maximum number of lines to ignore at the end of the text
* @param  {!boolean} closeParagraph Whether to close the paragraph at the end, if applicable
*/
function outputText(catchupPos, maxLines, closeParagraph)
{
	if (closeParagraph)
	{
		if (!(context.flags & RULE_CREATE_PARAGRAPHS))
		{
			closeParagraph = false;
		}
		else
		{
			// Ignore any number of lines at the end if we're closing a paragraph
			maxLines = -1;
		}
	}

	if (pos >= catchupPos)
	{
		// We're already there, close the paragraph if applicable and return
		if (closeParagraph)
		{
			outputParagraphEnd();
		}
	}

	// Skip over previously identified whitespace if applicable
	if (wsPos > pos)
	{
		var skipPos = Math.min(catchupPos, wsPos);
		output += text.substr(pos, skipPos - pos);
		pos = skipPos;

		if (pos >= catchupPos)
		{
			// Skipped everything. Close the paragraph if applicable and return
			if (closeParagraph)
			{
				outputParagraphEnd();
			}
		}
	}

	var catchupLen, catchupText;

	// Test whether we're even supposed to output anything
	if (HINT.RULE_IGNORE_TEXT && context.flags & RULE_IGNORE_TEXT)
	{
		catchupLen  = catchupPos - pos,
		catchupText = text.substr(pos, catchupLen);

		// If the catchup text is not entirely composed of whitespace, we put it inside ignore tags
		if (!/^[ \n\t]*$/.test(catchupText))
		{
			catchupText = '<i>' + catchupText + '</i>';
		}

		output += catchupText;
		pos = catchupPos;

		if (closeParagraph)
		{
			outputParagraphEnd();
		}

		return;
	}

	// Compute the amount of text to ignore at the end of the output
	var ignorePos = catchupPos,
		ignoreLen = 0;

	// Ignore as many lines (including whitespace) as specified
	while (maxLines && --ignorePos >= pos)
	{
		var c = text.charAt(ignorePos);
		if (c !== ' ' && c !== "\n" && c !== "\t")
		{
			break;
		}

		if (c === "\n")
		{
			--maxLines;
		}

		++ignoreLen;
	}

	// Adjust catchupPos to ignore the text at the end
	catchupPos -= ignoreLen;

	// Break down the text in paragraphs if applicable
	if (HINT.RULE_CREATE_PARAGRAPHS && context.flags & RULE_CREATE_PARAGRAPHS)
	{
		if (!context.inParagraph)
		{
			outputWhitespace(catchupPos);

			if (catchupPos > pos)
			{
				outputParagraphStart(catchupPos);
			}
		}

		// Look for a paragraph break in this text
		var pbPos = text.indexOf("\n\n", pos);

		while (pbPos > -1 && pbPos < catchupPos)
		{
			outputText(pbPos, 0, true);
			outputParagraphStart(catchupPos);

			pbPos = text.indexOf("\n\n", pos);
		}
	}

	// Capture, escape and output the text
	if (catchupPos > pos)
	{
		catchupText = htmlspecialchars_noquotes(
			text.substr(pos, catchupPos - pos)
		);

		// Format line breaks if applicable
		if (HINT.RULE_ENABLE_AUTO_BR && (context.flags & RULES_AUTO_LINEBREAKS) === RULE_ENABLE_AUTO_BR)
		{
			catchupText = catchupText.replace(/\n/g, "<br/>\n");
		}

		output += catchupText;
	}

	// Close the paragraph if applicable
	if (closeParagraph)
	{
		outputParagraphEnd();
	}

	// Add the ignored text if applicable
	if (ignoreLen)
	{
		output += text.substr(catchupPos, ignoreLen);
	}

	// Move the cursor past the text
	pos = catchupPos + ignoreLen;
}

/**
* Output a linebreak tag
*
* @param  {!Tag} tag
* @return void
*/
function outputBrTag(tag)
{
	outputText(tag.getPos(), 0, false);
	output += '<br/>';
}

/**
* Output an ignore tag
*
* @param  {!Tag} tag
* @return void
*/
function outputIgnoreTag(tag)
{
	var tagPos = tag.getPos(),
		tagLen = tag.getLen();

	// Capture the text to ignore
	var ignoreText = text.substr(tagPos, tagLen);

	// Catch up with the tag's position then output the tag
	outputText(tagPos, 0, false);
	output += '<i>' + htmlspecialchars_noquotes(ignoreText) + '</i>';
	isRich = true;

	// Move the cursor past this tag
	pos = tagPos + tagLen;
}

/**
* Start a paragraph between current position and given position, if applicable
*
* @param  {!number} maxPos Rightmost position at which the paragraph can be opened
*/
function outputParagraphStart(maxPos)
{
	if (!HINT.RULE_CREATE_PARAGRAPHS)
	{
		return;
	}

	// Do nothing if we're already in a paragraph, or if we don't use paragraphs
	if (context.inParagraph
	 || !(context.flags & RULE_CREATE_PARAGRAPHS))
	{
		return;
	}

	// Output the whitespace between pos and maxPos if applicable
	outputWhitespace(maxPos);

	// Open the paragraph, but only if it's not at the very end of the text
	if (pos < textLen)
	{
		output += '<p>';
		context.inParagraph = true;
	}
}

/**
* Close current paragraph at current position if applicable
*/
function outputParagraphEnd()
{
	// Do nothing if we're not in a paragraph
	if (!context.inParagraph)
	{
		return;
	}

	output += '</p>';
	context.inParagraph = false;
}

/**
* Skip as much whitespace after current position as possible
*
* @param  {!number} maxPos Rightmost character to be skipped
*/
function outputWhitespace(maxPos)
{
	while (pos < maxPos && " \n\t".indexOf(text.charAt(pos)) > -1)
	{
		output += text.charAt(pos);
		++pos;
	}
}

//==========================================================================
// Plugins handling
//==========================================================================

/**
* Disable a plugin
*
* @param {!string} pluginName Name of the plugin
*/
function disablePlugin(pluginName)
{
	if (plugins[pluginName])
	{
		plugins[pluginName].isDisabled = true;
	}
}

/**
* Enable a plugin
*
* @param {!string} pluginName Name of the plugin
*/
function enablePlugin(pluginName)
{
	if (plugins[pluginName])
	{
		plugins[pluginName].isDisabled = false;
	}
}

/**
* Get regexp matches in a manner similar to preg_match_all() with PREG_SET_ORDER | PREG_OFFSET_CAPTURE
*
* @param  {!RegExp} regexp
* @return {!Array.<!Array>}
*/
function getMatches(regexp)
{
	var matches = [], m;

	// Reset the regexp
	regexp.lastIndex = 0;

	while (m = regexp.exec(text))
	{
		// NOTE: coercing m.index to a number because Closure Compiler thinks pos is a string otherwise
		var pos   = +m['index'],
			match = [[m[0], pos]],
			i = 0;

		while (++i < m.length)
		{
			var str = m[i];

			// Sub-expressions that were not evaluated return undefined
			if (str === undefined)
			{
				match.push(['', -1]);
			}
			else
			{
				match.push([str, text.indexOf(str, pos)]);
				pos += str.length;
			}
		}

		matches.push(match);
	}

	return matches;
}

/**
* Execute all the plugins
*/
function executePluginParsers()
{
	for (var pluginName in plugins)
	{
		var plugin = plugins[pluginName];

		if (plugin.isDisabled)
		{
			continue;
		}

		if (plugin.quickMatch
		 && text.indexOf(plugin.quickMatch) < 0)
		{
			continue;
		}

		var matches = [];

		if (plugin.regexp)
		{
			matches = getMatches(plugin.regexp);

			var cnt = matches.length;

			if (!cnt)
			{
				continue;
			}

			if (cnt > plugin.regexpLimit)
			{
				if (HINT.regexpLimitActionAbort && plugin.regexpLimitAction === 'abort')
				{
					throw (pluginName + ' limit exceeded');
				}

				matches = matches.slice(0, plugin.regexpLimit);

				var msg = 'Regexp limit exceeded. Only the allowed number of matches will be processed',
					context = {
						'pluginName' : pluginName,
						'limit'      : plugin.regexpLimit
					};

				if (HINT.regexpLimitActionWarn && plugin.regexpLimitAction === 'warn')
				{
					logger.warn(msg, context);
				}
			}
		}

		// Execute the plugin's parser, which will add tags via addStartTag() and others
		plugin.parser(text, matches);
	}
}

/**
* Register a parser
*
* Can be used to add a new parser with no plugin config, or pre-generate a parser for an
* existing plugin
*
* @param  {!string}   pluginName
* @param  {!Function} parser
*/
function registerParser(pluginName, parser)
{
	// Create an empty config for this plugin to ensure it is executed
	if (!plugins[pluginName])
	{
		plugins[pluginName] = {};
	}

	plugins[pluginName].parser = parser;
}

//==========================================================================
// Rules handling
//==========================================================================

/**
* Apply closeAncestor rules associated with given tag
*
* @param  {!Tag}     tag Tag
* @return {!boolean}     Whether a new tag has been added
*/
function closeAncestor(tag)
{
	if (!HINT.closeAncestor)
	{
		return false;
	}

	if (openTags.length)
	{
		var tagName   = tag.getName(),
			tagConfig = tagsConfig[tagName];

		if (tagConfig.rules.closeAncestor)
		{
			var i = openTags.length;

			while (--i >= 0)
			{
				var ancestor     = openTags[i],
					ancestorName = ancestor.getName();

				if (tagConfig.rules.closeAncestor[ancestorName])
				{
					// We have to close this ancestor. First we reinsert this tag...
					tagStack.push(tag);

					// ...then we add a new end tag for it
					addMagicEndTag(ancestor, tag.getPos());

					return true;
				}
			}
		}
	}

	return false;
}

/**
* Apply closeParent rules associated with given tag
*
* @param  {!Tag}     tag Tag
* @return {!boolean}     Whether a new tag has been added
*/
function closeParent(tag)
{
	if (!HINT.closeParent)
	{
		return false;
	}

	if (openTags.length)
	{
		var tagName   = tag.getName(),
			tagConfig = tagsConfig[tagName];

		if (tagConfig.rules.closeParent)
		{
			var parent     = openTags[openTags.length - 1],
				parentName = parent.getName();

			if (tagConfig.rules.closeParent[parentName])
			{
				// We have to close that parent. First we reinsert the tag...
				tagStack.push(tag);

				// ...then we add a new end tag for it
				addMagicEndTag(parent, tag.getPos());

				return true;
			}
		}
	}

	return false;
}

/**
* Apply fosterParent rules associated with given tag
*
* NOTE: this rule has the potential for creating an unbounded loop, either if a tag tries to
*       foster itself or two or more tags try to foster each other in a loop. We mitigate the
*       risk by preventing a tag from creating a child of itself (the parent still gets closed)
*       and by checking and increasing the currentFixingCost so that a loop of multiple tags
*       do not run indefinitely. The default tagLimit and nestingLimit also serve to prevent the
*       loop from running indefinitely
*
* @param  {!Tag}     tag Tag
* @return {!boolean}     Whether a new tag has been added
*/
function fosterParent(tag)
{
	if (!HINT.fosterParent)
	{
		return false;
	}

	if (openTags.length)
	{
		var tagName   = tag.getName(),
			tagConfig = tagsConfig[tagName];

		if (tagConfig.rules.fosterParent)
		{
			var parent     = openTags[openTags.length - 1],
				parentName = parent.getName();

			if (tagConfig.rules.fosterParent[parentName])
			{
				if (parentName !== tagName && currentFixingCost < maxFixingCost)
				{
					// Add a 0-width copy of the parent tag right after this tag, and make it
					// depend on this tag
					var child = addCopyTag(parent, tag.getPos() + tag.getLen(), 0);
					tag.cascadeInvalidationTo(child);
				}

				++currentFixingCost;

				// Reinsert current tag
				tagStack.push(tag);

				// And finally close its parent
				addMagicEndTag(parent, tag.getPos());

				return true;
			}
		}
	}

	return false;
}

/**
* Apply requireAncestor rules associated with given tag
*
* @param  {!Tag}     tag Tag
* @return {!boolean}     Whether this tag has an unfulfilled requireAncestor requirement
*/
function requireAncestor(tag)
{
	if (!HINT.requireAncestor)
	{
		return false;
	}

	var tagName   = tag.getName(),
		tagConfig = tagsConfig[tagName];

	if (tagConfig.rules.requireAncestor)
	{
		var i = tagConfig.rules.requireAncestor.length;
		while (--i >= 0)
		{
			var ancestorName = tagConfig.rules.requireAncestor[i];
			if (cntOpen[ancestorName])
			{
				return false;
			}
		}

		logger.err('Tag requires an ancestor', {
			'requireAncestor' : tagConfig.rules.requireAncestor.join(', '),
			'tag'             : tag
		});

		return true;
	}

	return false;
}

//==========================================================================
// Tag processing
//==========================================================================

/**
* Create and add an end tag for given start tag at given position
*
* @param  {!Tag}    startTag Start tag
* @param  {!number} tagPos   End tag's position (will be adjusted for whitespace if applicable)
*/
function addMagicEndTag(startTag, tagPos)
{
	var tagName = startTag.getName();

	// Adjust the end tag's position if whitespace is to be minimized
	if (HINT.RULE_TRIM_WHITESPACE && (startTag.getFlags() & RULE_TRIM_WHITESPACE))
	{
		tagPos = getMagicPos(tagPos);
	}

	// Add a 0-width end tag that is paired with the given start tag
	addEndTag(tagName, tagPos, 0).pairWith(startTag);
}

/**
* Compute the position of a magic end tag, adjusted for whitespace
*
* @param  {!number} tagPos Rightmost possible position for the tag
* @return {!number}
*/
function getMagicPos(tagPos)
{
	// Back up from given position to the cursor's position until we find a character that
	// is not whitespace
	while (tagPos > pos && WHITESPACE.indexOf(text.charAt(tagPos - 1)) > -1)
	{
		--tagPos;
	}

	return tagPos;
}

/**
* Process all tags in the stack
*/
function processTags()
{
	// Reset some internal vars
	pos        = 0;
	cntOpen    = {};
	cntTotal   = {};
	openTags   = [];
	currentTag = null;

	// Initialize the root context
	context = rootContext;
	context.inParagraph = false;

	// Initialize the count tables
	for (var tagName in tagsConfig)
	{
		cntOpen[tagName]  = 0;
		cntTotal[tagName] = 0;
	}

	// Process the tag stack, close tags that were left open and repeat until done
	do
	{
		while (tagStack.length)
		{
			if (!tagStackIsSorted)
			{
				sortTags();
			}

			currentTag = tagStack.pop();

			// Skip current tag if tags are disabled and current tag would not close the last
			// open tag and is not a special tag such as a line/paragraph break or an ignore tag
			if (context.flags & RULE_IGNORE_TAGS)
			{
				if (!currentTag.canClose(openTags[openTags.length - 1])
				 && !currentTag.isSystemTag())
				{
					continue;
				}
			}

			processCurrentTag();
		}

		// Close tags that were left open
		openTags.forEach(function (startTag)
		{
			// NOTE: we add tags in hierarchical order (ancestors to descendants) but since
			//       the stack is processed in LIFO order, it means that tags get closed in
			//       the correct order, from descendants to ancestors
			addMagicEndTag(startTag, textLen);
		});
	}
	while (tagStack.length);

	// Finalize the document
	finalizeOutput();
}

/**
* Process current tag
*/
function processCurrentTag()
{
	if (currentTag.isInvalid())
	{
		return;
	}

	var tagPos = currentTag.getPos(),
		tagLen = currentTag.getLen();

	// Test whether the cursor passed this tag's position already
	if (pos > tagPos)
	{
		// Test whether this tag is paired with a start tag and this tag is still open
		var startTag = currentTag.getStartTag();

		if (startTag && openTags.indexOf(startTag) >= 0)
		{
			// Create an end tag that matches current tag's start tag, which consumes as much of
			// the same text as current tag and is paired with the same start tag
			addEndTag(
				startTag.getName(),
				pos,
				Math.max(0, tagPos + tagLen - pos)
			).pairWith(startTag);

			// Note that current tag is not invalidated, it's merely replaced
			return;
		}

		// If this is an ignore tag, try to ignore as much as the remaining text as possible
		if (currentTag.isIgnoreTag())
		{
			var ignoreLen = tagPos + tagLen - pos;

			if (ignoreLen > 0)
			{
				// Create a new ignore tag and move on
				addIgnoreTag(pos, ignoreLen);

				return;
			}
		}

		// Skipped tags are invalidated
		currentTag.invalidate();

		return;
	}

	if (currentTag.isIgnoreTag())
	{
		outputIgnoreTag(currentTag);
	}
	else if (currentTag.isBrTag())
	{
		// Output the tag if it's allowed, ignore it otherwise
		if (!HINT.RULE_PREVENT_BR || !(context.flags & RULE_PREVENT_BR))
		{
			outputBrTag(currentTag);
		}
	}
	else if (currentTag.isParagraphBreak())
	{
		outputText(currentTag.getPos(), 0, true);
	}
	else if (currentTag.isStartTag())
	{
		processStartTag(currentTag);
	}
	else
	{
		processEndTag(currentTag);
	}
}

/**
* Process given start tag (including self-closing tags) at current position
*
* @param {!Tag} tag Start tag (including self-closing)
*/
function processStartTag(tag)
{
	var tagName   = tag.getName(),
		tagConfig = tagsConfig[tagName];

	// 1. Check that this tag has not reached its global limit tagLimit
	// 2. Execute this tag's filterChain, which will filter/validate its attributes
	// 3. Apply closeParent, closeAncestor and fosterParent rules
	// 4. Check for nestingLimit
	// 5. Apply requireAncestor rules
	//
	// This order ensures that the tag is valid and within the set limits before we attempt to
	// close parents or ancestors. We need to close ancestors before we can check for nesting
	// limits, whether this tag is allowed within current context (the context may change
	// as ancestors are closed) or whether the required ancestors are still there (they might
	// have been closed by a rule.)
	if (cntTotal[tagName] >= tagConfig.tagLimit)
	{
		logger.err(
			'Tag limit exceeded',
			{
				'tag'      : tag,
				'tagName'  : tagName,
				'tagLimit' : tagConfig.tagLimit
			}
		);
		tag.invalidate();

		return;
	}

	if (!filterTag(tag))
	{
		tag.invalidate();

		return;
	}

	if (fosterParent(tag) || closeParent(tag) || closeAncestor(tag))
	{
		// This tag parent/ancestor needs to be closed, we just return (the tag is still valid)
		return;
	}

	if (cntOpen[tagName] >= tagConfig.nestingLimit)
	{
		logger.err(
			'Nesting limit exceeded',
			{
				'tag'          : tag,
				'tagName'      : tagName,
				'nestingLimit' : tagConfig.nestingLimit
			}
		);
		tag.invalidate();

		return;
	}

	if (!tagIsAllowed(tagName))
	{
		logger.warn(
			'Tag is not allowed in this context',
			{
				'tag'     : tag,
				'tagName' : tagName
			}
		);
		tag.invalidate();

		return;
	}

	if (requireAncestor(tag))
	{
		tag.invalidate();

		return;
	}

	// If this tag has an autoClose rule and it's not paired with an end tag, we replace it
	// with a self-closing tag with the same properties
	if (HINT.RULE_AUTO_CLOSE
	 && tag.getFlags() & RULE_AUTO_CLOSE
	 && !tag.getEndTag())
	{
		var newTag = new Tag(Tag.SELF_CLOSING_TAG, tagName, tag.getPos(), tag.getLen());
		newTag.setAttributes(tag.getAttributes());
		newTag.setFlags(tag.getFlags());

		tag = newTag;
	}

	// This tag is valid, output it and update the context
	outputTag(tag);
	pushContext(tag);
}

/**
* Process given end tag at current position
*
* @param {!Tag} tag End tag
*/
function processEndTag(tag)
{
	var tagName = tag.getName();

	if (!cntOpen[tagName])
	{
		// This is an end tag with no start tag
		return;
	}

	/**
	* @type {!Array.<!Tag>} List of tags need to be closed before given tag
	*/
	var closeTags = [];

	// Iterate through all open tags from last to first to find a match for our tag
	var i = openTags.length;
	while (--i >= 0)
	{
		var openTag = openTags[i];

		if (tag.canClose(openTag))
		{
			break;
		}

		if (++currentFixingCost > maxFixingCost)
		{
			throw 'Fixing cost exceeded';
		}

		closeTags.push(openTag);
	}

	if (i < 0)
	{
		// Did not find a matching tag
		logger.debug('Skipping end tag with no start tag', {'tag': tag});

		return;
	}

	// Only reopen tags if we haven't exceeded our "fixing" budget
	var keepReopening = HINT.RULE_AUTO_REOPEN && (currentFixingCost < maxFixingCost),
		reopenTags    = [];
	closeTags.forEach(function(openTag)
	{
		var openTagName = openTag.getName();

		// Test whether this tag should be reopened automatically
		if (keepReopening)
		{
			if (openTag.getFlags() & RULE_AUTO_REOPEN)
			{
				reopenTags.push(openTag);
			}
			else
			{
				keepReopening = false;
			}
		}

		// Find the earliest position we can close this open tag
		var tagPos = tag.getPos();
		if (HINT.RULE_TRIM_WHITESPACE && openTag.getFlags() & RULE_TRIM_WHITESPACE)
		{
			tagPos = getMagicPos(tagPos);
		}

		// Output an end tag to close this start tag, then update the context
		var endTag = new Tag(Tag.END_TAG, openTagName, tagPos, 0);
		endTag.setFlags(openTag.getFlags());
		outputTag(endTag);
		popContext();
	});

	// Output our tag, moving the cursor past it, then update the context
	outputTag(tag);
	popContext();

	// If our fixing budget allows it, peek at upcoming tags and remove end tags that would
	// close tags that are already being closed now. Also, filter our list of tags being
	// reopened by removing those that would immediately be closed
	if (closeTags.length && currentFixingCost < maxFixingCost)
	{
		/**
		* @type {number} Rightmost position of the portion of text to ignore
		*/
		var ignorePos = pos;

		i = tagStack.length;
		while (--i >= 0 && ++currentFixingCost < maxFixingCost)
		{
			var upcomingTag = tagStack[i];

			// Test whether the upcoming tag is positioned at current "ignore" position and it's
			// strictly an end tag (not a start tag or a self-closing tag)
			if (upcomingTag.getPos() > ignorePos
			 || upcomingTag.isStartTag())
			{
				break;
			}

			// Test whether this tag would close any of the tags we're about to reopen
			var j = closeTags.length;

			while (--j >= 0 && ++currentFixingCost < maxFixingCost)
			{
				if (upcomingTag.canClose(closeTags[j]))
				{
					// Remove the tag from the lists and reset the keys
					closeTags.splice(j, 1);

					if (reopenTags[j])
					{
						reopenTags.splice(j, 1);
					}

					// Extend the ignored text to cover this tag
					ignorePos = Math.max(
						ignorePos,
						upcomingTag.getPos() + upcomingTag.getLen()
					);

					break;
				}
			}
		}

		if (ignorePos > pos)
		{
			/**
			* @todo have a method that takes (pos,len) rather than a Tag
			*/
			outputIgnoreTag(new Tag(Tag.SELF_CLOSING_TAG, 'i', pos, ignorePos - pos));
		}
	}

	// Re-add tags that need to be reopened, at current cursor position
	reopenTags.forEach(function(startTag)
	{
		var newTag = addCopyTag(startTag, pos, 0);

		// Re-pair the new tag
		var endTag = startTag.getEndTag();
		if (endTag)
		{
			newTag.pairWith(endTag);
		}
	});
}

/**
* Update counters and replace current context with its parent context
*/
function popContext()
{
	var tag = openTags.pop();
	--cntOpen[tag.getName()];
	context = context.parentContext;
}

/**
* Update counters and replace current context with a new context based on given tag
*
* If given tag is a self-closing tag, the context won't change
*
* @param {!Tag} tag Start tag (including self-closing)
*/
function pushContext(tag)
{
	var tagName   = tag.getName(),
		tagFlags  = tag.getFlags(),
		tagConfig = tagsConfig[tagName];

	++cntTotal[tagName];

	// If this is a self-closing tag, we don't need to do anything else; The context remains the
	// same
	if (tag.isSelfClosingTag())
	{
		return;
	}

	++cntOpen[tagName];
	openTags.push(tag);

	/**
	* @param {!Array} a1
	* @param {!Array} a2
	*/
	function contextAnd(a1, a2)
	{
		var i = -1, cnt = a1.length, ret = new Array(cnt);

		while (++i < cnt)
		{
			ret[i] = a1[i] & a2[i];
		}

		return ret;
	}

	// Using contextAnd() to copy the array
	var allowedChildren = contextAnd(tagConfig.allowedChildren, tagConfig.allowedChildren);

	// If the tag is transparent, we restrict its allowed children to the same set as its
	// parent, minus this tag's own disallowed children
	if (HINT.RULE_IS_TRANSPARENT && (tagFlags & RULE_IS_TRANSPARENT))
	{
		allowedChildren = contextAnd(allowedChildren, context.allowedChildren);
	}

	// The allowedDescendants bitfield is restricted by this tag's
	var allowedDescendants = contextAnd(
		context.allowedDescendants,
		tagConfig.allowedDescendants
	);

	// Ensure that disallowed descendants are not allowed as children
	allowedChildren = contextAnd(
		allowedChildren,
		allowedDescendants
	);

	// Use this tag's flags as a base for this context
	var flags = tagFlags;

	// Add inherited rules
	flags |= context.flags & RULES_INHERITANCE;

	// RULE_DISABLE_AUTO_BR turns off RULE_ENABLE_AUTO_BR
	if (flags & RULE_DISABLE_AUTO_BR)
	{
		flags &= ~RULE_ENABLE_AUTO_BR;
	}

	context = {
		allowedChildren    : allowedChildren,
		allowedDescendants : allowedDescendants,
		flags              : flags,
		parentContext      : context
	};
}

/**
* Return whether given tag is allowed in current context
*
* @param  {!string}  tagName
* @return {!boolean}
*/
function tagIsAllowed(tagName)
{
	var n = tagsConfig[tagName].bitNumber;

	return !!(context.allowedChildren[n >> 5] & (1 << (n & 31)));
}

//==========================================================================
// Tag stack
//==========================================================================

/**
* Add a start tag
*
* @param  {!string} name Name of the tag
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @return {!Tag}
*/
function addStartTag(name, pos, len)
{
	return addTag(Tag.START_TAG, name, pos, len);
}

/**
* Add an end tag
*
* @param  {!string} name Name of the tag
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @return {!Tag}
*/
function addEndTag(name, pos, len)
{
	return addTag(Tag.END_TAG, name, pos, len);
}

/**
* Add a self-closing tag
*
* @param  {!string} name Name of the tag
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @return {!Tag}
*/
function addSelfClosingTag(name, pos, len)
{
	return addTag(Tag.SELF_CLOSING_TAG, name, pos, len);
}

/**
* Add a 0-width "br" tag to force a line break at given position
*
* @param  {!number} pos  Position of the tag in the text
* @return {!Tag}
*/
function addBrTag(pos)
{
	return addTag(Tag.SELF_CLOSING_TAG, 'br', pos, 0);
}

/**
* Add an "ignore" tag
*
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @return {!Tag}
*/
function addIgnoreTag(pos, len)
{
	return addTag(Tag.SELF_CLOSING_TAG, 'i', pos, len);
}

/**
* Add a paragraph break at given position
*
* Uses a zero-width tag that is actually never output in the result
*
* @param  {!number} pos  Position of the tag in the text
* @return {!Tag}
*/
function addParagraphBreak(pos)
{
	return addTag(Tag.SELF_CLOSING_TAG, 'pb', pos, 0);
}

/**
* Add a copy of given tag at given position and length
*
* @param  {!Tag}    tag Original tag
* @param  {!number} pos Copy's position
* @param  {!number} len Copy's length
* @return {!Tag}        Copy tag
*/
function addCopyTag(tag, pos, len)
{
	var copy = addTag(tag.getType(), tag.getName(), pos, len);
	copy.setAttributes(tag.getAttributes());
	copy.setSortPriority(tag.getSortPriority());

	return copy;
}

/**
* Add a tag
*
* @param  {!number} type Tag's type
* @param  {!string} name Name of the tag
* @param  {!number} pos  Position of the tag in the text
* @param  {!number} len  Length of text consumed by the tag
* @return {!Tag}
*/
function addTag(type, name, pos, len)
{
	// Create the tag
	var tag = new Tag(type, name, pos, len);

	// Set this tag's rules bitfield
	if (tagsConfig[name])
	{
		tag.setFlags(tagsConfig[name].rules.flags);
	}

	// Invalidate this tag if it's an unknown tag, a disabled tag, if either of its length or
	// position is negative or if it's out of bounds
	if (!tagsConfig[name] && !tag.isSystemTag())
	{
		tag.invalidate();
	}
	else if (tagsConfig[name] && tagsConfig[name].isDisabled)
	{
		logger.warn(
			'Tag is disabled',
			{
				'tag'     : tag,
				'tagName' : name
			}
		);
		tag.invalidate();
	}
	else if (len < 0 || pos < 0 || pos + len > textLen)
	{
		tag.invalidate();
	}
	else
	{
		// If the stack is sorted we check whether this tag should be stored at a lower offset
		// than the last tag which would mean we need to sort the stack. Note that we cannot use
		// compareTags() to break ties here because setSortPriority() can be called *after* tags
		// have been put on the stack, therefore we need to properly sort the stack if the
		// positions are the same
		if (tagStackIsSorted
		 && tagStack.length
		 && tag.getPos() >= tagStack[tagStack.length - 1].getPos())
		{
			tagStackIsSorted = false;
		}

		tagStack.push(tag);
	}

	return tag;
}

/**
* Add a pair of tags
*
* @param  {!string} name     Name of the tags
* @param  {!number} startPos Position of the start tag
* @param  {!number} startLen Length of the starttag
* @param  {!number} endPos   Position of the start tag
* @param  {!number} endLen   Length of the starttag
* @return {!Tag}             Start tag
*/
function addTagPair(name, startPos, startLen, endPos, endLen)
{
	var tag = addStartTag(name, startPos, startLen);
	tag.pairWith(addEndTag(name, endPos, endLen));

	return tag;
}

/**
* Sort tags by position and precedence
*/
function sortTags()
{
	tagStack.sort(compareTags);
	tagStackIsSorted = true;
}

/**
* sortTags() callback
*
* Tags are stored as a stack, in LIFO order. We sort tags by position _descending_ so that they
* are processed in the order they appear in the text.
*
* @param  {!Tag}    a First tag to compare
* @param  {!Tag}    b Second tag to compare
* @return {!number}
*/
function compareTags(a, b)
{
	var aPos = a.getPos(),
		bPos = b.getPos();

	// First we order by pos descending
	if (aPos !== bPos)
	{
		return bPos - aPos;
	}

	// If the tags start at the same position, we'll use their sortPriority if applicable. Tags
	// with a lower value get sorted last, which means they'll be processed first. IOW, -10 is
	// processed before 10
	if (a.getSortPriority() !== b.getSortPriority())
	{
		return b.getSortPriority() - a.getSortPriority();
	}

	// If the tags start at the same position and have the same priority, we'll sort them
	// according to their length, with special considerations for  zero-width tags
	var aLen = a.getLen(),
		bLen = b.getLen();

	if (!aLen || !bLen)
	{
		// Zero-width end tags are ordered after zero-width start tags so that a pair that ends
		// with a zero-width tag has the opportunity to be closed before another pair starts
		// with a zero-width tag. For example, the pairs that would enclose each of the letters
		// in the string "XY". Self-closing tags are ordered between end tags and start tags in
		// an attempt to keep them out of tag pairs
		if (!aLen && !bLen)
		{
			var order = {};
			order[Tag.END_TAG]          = 0;
			order[Tag.SELF_CLOSING_TAG] = 1;
			order[Tag.START_TAG]        = 2;

			return order[b.getType()] - order[a.getType()];
		}

		// Here, we know that only one of a or b is a zero-width tags. Zero-width tags are
		// ordered after wider tags so that they have a chance to be processed before the next
		// character is consumed, which would force them to be skipped
		return (aLen) ? -1 : 1;
	}

	// Here we know that both tags start at the same position and have a length greater than 0.
	// We sort tags by length ascending, so that the longest matches are processed first. If
	// their length is identical, the order is undefined as PHP's sort isn't stable
	return aLen - bLen;
}
/** @const */ var xsl="<?xml version=\"1.0\" encoding=\"utf-8\"?><xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\" xmlns:html=\"urn:s9e:TextFormatter:html\" exclude-result-prefixes=\"html\"><xsl:output method=\"html\" encoding=\"utf-8\" indent=\"no\"\/><xsl:template match=\"B|I|LI|S|U|html:b|p\"><xsl:element name=\"{translate(local-name(),'BILSU','bilsu')}\"><xsl:apply-templates\/><\/xsl:element><\/xsl:template><xsl:template match=\"C\"><code class=\"inline\"><xsl:apply-templates\/><\/code><\/xsl:template><xsl:template match=\"CENSOR\"><xsl:choose><xsl:when test=\"@with\"><xsl:value-of select=\"@with\"\/><\/xsl:when><xsl:otherwise>****<\/xsl:otherwise><\/xsl:choose><\/xsl:template><xsl:template match=\"CODE\"><pre data-s9e-livepreview-postprocess=\"if('undefined'!==typeof hljs){{var a=this.innerHTML;a in hljs._?this.innerHTML=hljs._[a]:(Object.keys&amp;&amp;7&lt;Object.keys(hljs._).length&amp;&amp;(hljs._={{}}),hljs.highlightBlock(this.firstChild),hljs._[a]=this.innerHTML)}};\"><code class=\"{@lang}\"><xsl:apply-templates\/><\/code><\/pre><xsl:if test=\"not(following::CODE)\"><script>if(\"undefined\"===typeof hljs){var a=document.getElementsByTagName(\"head\")[0],b=document.createElement(\"link\");b.type=\"text\/css\";b.rel=\"stylesheet\";b.href=\"\/\/cdnjs.cloudflare.com\/ajax\/libs\/highlight.js\/7.3\/styles\/github.min.css\";a.appendChild(b);b=document.createElement(\"script\");b.type=\"text\/javascript\";b.onload=function(){hljs._={};hljs.initHighlighting()};b.async=!0;b.src=\"\/\/cdnjs.cloudflare.com\/ajax\/libs\/highlight.js\/7.3\/highlight.min.js\";a.appendChild(b)};<\/script><\/xsl:if><\/xsl:template><xsl:template match=\"COLOR\"><span style=\"color:{@color}\"><xsl:apply-templates\/><\/span><\/xsl:template><xsl:template match=\"E\"><xsl:choose><xsl:when test=\".=':)'\"><img src=\"s.png\" alt=\":)\"\/><\/xsl:when><xsl:otherwise><xsl:value-of select=\".\"\/><\/xsl:otherwise><\/xsl:choose><\/xsl:template><xsl:template match=\"FLOAT\"><div style=\"float:{@float}\"><xsl:apply-templates\/><\/div><\/xsl:template><xsl:template match=\"FP|HE\"><xsl:value-of select=\"@char\"\/><\/xsl:template><xsl:template match=\"G60D5AB76\"><a href=\"https:\/\/twitter.com\/#!\/search\/%23{@tag}\"><xsl:apply-templates\/><\/a><\/xsl:template><xsl:template match=\"LIST\"><xsl:choose><xsl:when test=\"not(@type)\"><ul><xsl:apply-templates\/><\/ul><\/xsl:when><xsl:when test=\"contains('upperlowerdecim',substring(@type,1,5))\"><ol style=\"list-style-type:{@type}\"><xsl:apply-templates\/><\/ol><\/xsl:when><xsl:otherwise><ul style=\"list-style-type:{@type}\"><xsl:apply-templates\/><\/ul><\/xsl:otherwise><\/xsl:choose><\/xsl:template><xsl:template match=\"QUOTE\"><blockquote><xsl:if test=\"not(@author)\"><xsl:attribute name=\"class\">uncited<\/xsl:attribute><\/xsl:if><div><xsl:if test=\"@author\"><cite><xsl:value-of select=\"@author\"\/> wrote:<\/cite><\/xsl:if><xsl:apply-templates\/><\/div><\/blockquote><\/xsl:template><xsl:template match=\"URL\"><a href=\"{@url}\"><xsl:copy-of select=\"@title\"\/><xsl:apply-templates\/><\/a><\/xsl:template><xsl:template match=\"YOUTUBE\"><iframe width=\"240\" height=\"180\" src=\"http:\/\/www.youtube.com\/embed\/{@id}\" allowfullscreen=\"\"\/><\/xsl:template><xsl:template match=\"br\"><br\/><\/xsl:template><xsl:template match=\"e|i|s\"\/><xsl:template match=\"html:a\"><a><xsl:copy-of select=\"@href\"\/><xsl:copy-of select=\"@title\"\/><xsl:apply-templates\/><\/a><\/xsl:template><\/xsl:stylesheet>";
var xslt;
console.log(typeof DOMParser !== 'undefined' && typeof XSLTProcessor !== 'undefined');
console.log(typeof DOMParser !== 'undefined');
console.log(typeof XSLTProcessor !== 'undefined');
if (typeof DOMParser !== 'undefined' && typeof XSLTProcessor !== 'undefined')
{
	var xslt = new XSLTProcessor;
	xslt['importStylesheet'](loadXML(xsl));

	/**
	* @param {!string} xml
	*/
	function loadXML(xml)
	{
		return (new DOMParser).parseFromString(xml, 'text/xml');
	}

	/**
	* @param {!string} xml
	* @param {!HTMLDocument} targetDoc
	*/
	function transformToFragment(xml, targetDoc)
	{
		// NOTE: importNode() is used because of https://code.google.com/p/chromium/issues/detail?id=266305
		return targetDoc.importNode(xslt['transformToFragment'](loadXML(xml), targetDoc), true)
	}
}
else
{
	var xslt = loadXML(xsl);

	/**
	* @param {!string} xml
	*/
	function loadXML(xml)
	{
		var obj = new ActiveXObject('MSXML2.DOMDocument.3.0');
		obj.async = false;
		obj.validateOnParse = false;
		obj.loadXML(xml);

		return obj;
	}

	/**
	* @param {!string} xml
	* @param {!HTMLDocument} targetDoc
	*/
	function transformToFragment(xml, targetDoc)
	{
		var div = targetDoc.createElement('div'),
			fragment = targetDoc.createDocumentFragment();

		div.innerHTML = loadXML(xml).transformNode(xslt);
		while (div.firstChild)
		{
			fragment.appendChild(div.removeChild(div.firstChild));
		}

		return fragment;
	}
}

var postProcessFunctions = {};

/**
* Parse a given text and render it into given HTML element
*
* @param {!string} text
* @param {!HTMLElement} target
*/
function preview(text, target)
{
	var targetDoc = target.ownerDocument,
		resultFragment = transformToFragment(parse(text), targetDoc);

	// Apply post-processing
	if (HINT.postProcessing)
	{
		var nodes = resultFragment['querySelectorAll']('[data-s9e-livepreview-postprocess]'),
			i     = nodes.length;
		while (--i >= 0)
		{
			/** @type {!string} */
			var code = nodes[i]['getAttribute']('data-s9e-livepreview-postprocess');

			if (!postProcessFunctions[code])
			{
				postProcessFunctions[code] = new Function(code);
			}

			postProcessFunctions[code]['call'](nodes[i]);
		}
	}

	/**
	* Update the content of given element oldEl to match element newEl
	*
	* @param {!HTMLElement} oldEl
	* @param {!HTMLElement} newEl
	*/
	function refreshElementContent(oldEl, newEl)
	{
		var oldNodes = oldEl.childNodes,
			newNodes = newEl.childNodes,
			oldCnt = oldNodes.length,
			newCnt = newNodes.length,
			oldNode,
			newNode,
			left  = 0,
			right = 0;

		// Skip the leftmost matching nodes
		while (left < oldCnt && left < newCnt)
		{
			oldNode = oldNodes[left];
			newNode = newNodes[left];

			if (!refreshNode(oldNode, newNode))
			{
				break;
			}

			++left;
		}

		// Skip the rightmost matching nodes
		var maxRight = Math.min(oldCnt - left, newCnt - left);

		while (right < maxRight)
		{
			oldNode = oldNodes[oldCnt - (right + 1)];
			newNode = newNodes[newCnt - (right + 1)];

			if (!refreshNode(oldNode, newNode))
			{
				break;
			}

			++right;
		}

		// Clone the new nodes
		var newNodesFragment = targetDoc.createDocumentFragment(),
			i = left;

		while (i < (newCnt - right))
		{
			newNode = newNodes[i].cloneNode(true);

			newNodesFragment.appendChild(newNode);
			++i;
		}

		// Remove the old dirty nodes in the middle of the tree
		i = oldCnt - right;
		while (--i >= left)
		{
			oldEl.removeChild(oldNodes[i]);
		}

		// If we haven't skipped any nodes to the right, we can just append the fragment
		if (!right)
		{
			oldEl.appendChild(newNodesFragment);
		}
		else
		{
			oldEl.insertBefore(newNodesFragment, oldEl.childNodes[left]);
		}
	}

	/**
	* Update given node oldNode to make it match newNode
	*
	* @param {!HTMLElement} oldNode
	* @param {!HTMLElement} newNode
	* @return boolean Whether the node can be skipped
	*/
	function refreshNode(oldNode, newNode)
	{
		if (oldNode.nodeName !== newNode.nodeName
		 || oldNode.nodeType !== newNode.nodeType)
		{
			return false;
		}

		// Node.TEXT_NODE || Node.COMMENT_NODE
		if (oldNode.nodeType === 3 || oldNode.nodeType === 8)
		{
			if (oldNode.nodeValue !== newNode.nodeValue)
			{
				oldNode.nodeValue = newNode.nodeValue;
			}

			return true;
		}

		if (oldNode.isEqualNode && oldNode.isEqualNode(newNode))
		{
			return true;
		}

		syncElementAttributes(oldNode, newNode);
		refreshElementContent(oldNode, newNode);

		return true;
	}

	/**
	* Make the set of attributes of given element oldEl match newEl's
	*
	* @param {!HTMLElement} oldEl
	* @param {!HTMLElement} newEl
	*/
	function syncElementAttributes(oldEl, newEl)
	{
		var oldAttributes = oldEl['attributes'],
			newAttributes = newEl['attributes'],
			oldCnt = oldAttributes.length,
			newCnt = newAttributes.length,
			i = oldCnt;

		while (--i >= 0)
		{
			var oldAttr      = oldAttributes[i],
				namespaceURI = oldAttr['namespaceURI'],
				attrName     = oldAttr['name'];

			if (!newEl.hasAttributeNS(namespaceURI, attrName))
			{
				oldEl.removeAttributeNS(namespaceURI, attrName);
			}
		}

		i = newCnt;
		while (--i >= 0)
		{
			var newAttr      = newAttributes[i],
				namespaceURI = newAttr['namespaceURI'],
				attrName     = newAttr['name'],
				attrValue    = newAttr['value'];

			if (attrValue !== oldEl.getAttributeNS(namespaceURI, attrName))
			{
				oldEl.setAttributeNS(namespaceURI, attrName, attrValue);
			}
		}
	}

	refreshElementContent(target, resultFragment);
}

/**
* Set the value of a stylesheet parameter
*
* @param {!string} paramName  Parameter name
* @param {!string} paramValue Parameter's value
*/
function setParameter(paramName, paramValue)
{
	xslt['setParameter'](null, paramName, paramValue);
}

/**
* @param {!Tag} tag
* @param {!Object} tagConfig
*/
function c2503AA6D(tag,tagConfig){return filterAttributes(tag,tagConfig,registeredVars,logger);}
/**
* @param {*} attrValue
* @param {!string} attrName
*/
function cC9B15C5A(attrValue,attrName){return (BuiltInFilters.filterUrl)(attrValue,registeredVars["urlConfig"],logger);}
/**
* @param {*} attrValue
* @param {!string} attrName
*/
function c9BA30EFD(attrValue,attrName){return (BuiltInFilters.filterHashmap)(attrValue,{"A":"upper-alpha","I":"upper-roman","a":"lower-alpha","i":"lower-roman",1:"decimal"},!1);}
/**
* @param {*} attrValue
* @param {!string} attrName
*/
function c796767C5(attrValue,attrName){return (BuiltInFilters.filterSimpletext)(attrValue);}
/**
* @param {*} attrValue
* @param {!string} attrName
*/
function c26B0971A(attrValue,attrName){return (BuiltInFilters.filterColor)(attrValue);}
/**
* @param {*} attrValue
* @param {!string} attrName
*/
function c6CC3304F(attrValue,attrName){return (BuiltInFilters.filterRegexp)(attrValue,/^(?:left|none|right)$/i);}
/**
* @param {*} attrValue
* @param {!string} attrName
*/
function c59E8427B(attrValue,attrName){return (BuiltInFilters.filterIdentifier)(attrValue);}
/**
* @param {*} attrValue
* @param {!string} attrName
*/
function c9A7991A2(attrValue,attrName){return (BuiltInFilters.filterRegexp)(attrValue,/^([a-z0-9]+)$/i);}
/**
* @param {!Tag} tag
* @param {!Object} tagConfig
*/
function c5C101E80(tag,tagConfig){return (/**
* Filter a MEDIA tag
*
* This will always invalidate the original tag, and possibly replace it with the tag that
* corresponds to the media site
*
* @param  {!Tag}     tag      The original tag
* @param  {*}        tagStack Unused
* @param  {!Object}  sites    Map of [host => siteId]
* @return {!boolean}          Always false
*/
function (tag, tagStack, sites)
{
	var tagName;

	if (tag.hasAttribute('media'))
	{
		// [media=youtube]xxxxxxx[/media]
		tagName = tag.getAttribute('media');

		// If this tag doesn't have an id attribute and the url attribute doesn't really look
		// like an URL, copy the value of the url attribute, so that the tag acts like
		// [media=youtube id=xxxx]xxxx[/media]
		if (!tag.hasAttribute('id')
		 && tag.hasAttribute('url')
		 && tag.getAttribute('url').indexOf('://') === -1)
		{
			tag.setAttribute('id', tag.getAttribute('url'));
		}
	}
	else if (tag.hasAttribute('url'))
	{
		// Capture the scheme and host of the URL
		var p = /^(?:([^:]+):)?(?:\/\/([^\/]+))?/.exec(tag.getAttribute('url'));

		if (p[1] && sites[p[1] + ':'])
		{
			tagName = sites[p[1] + ':'];
		}
		else if (p[2])
		{
			var host = p[2];

			// Start with the full host then pop domain labels off the start until we get a
			// match
			do
			{
				if (sites[host])
				{
					tagName = sites[host];
					break;
				}

				var pos = host.indexOf('.');
				if (pos == -1)
				{
					break;
				}

				host = host.substr(1 + pos);
			}
			while (host > '');
		}
	}

	if (tagName)
	{
		var endTag = tag.getEndTag() || tag;

		// Compute the boundaries of our new tag
		var lpos = tag.getPos(),
			rpos = endTag.getPos() + endTag.getLen();

		// Create a new tag and copy this tag's attributes and priority
		var newTag = addSelfClosingTag(tagName.toUpperCase(), lpos, rpos - lpos);
		newTag.setAttributes(tag.getAttributes());
		newTag.setSortPriority(tag.getSortPriority());
	}

	return false;
})(tag,registeredVars["parser"],registeredVars["mediasites"]);}
/**
* @param {!Tag} tag
* @param {!Object} tagConfig
*/
function c0FD361FA(tag,tagConfig){return executeAttributePreprocessors(tag,tagConfig);}
/**
* @param {*} attrValue
* @param {!string} attrName
*/
function cDF0F1849(attrValue,attrName){return (BuiltInFilters.filterRegexp)(attrValue,/^(?:[-\w]+)$/);}
/**
* @param {*} attrValue
* @param {!string} attrName
*/
function c6D49533B(attrValue,attrName){return (BuiltInFilters.filterRegexp)(attrValue,/^(?:\d+)$/);}
window['s9e'] = { 'TextFormatter': {'disablePlugin':disablePlugin,'enablePlugin':enablePlugin,'preview':preview} }

		var text,
			textareaEl = document.getElementsByTagName('textarea')[0],
			previewEl = document.getElementById('preview');

		window.setInterval(function()
		{
			if (textareaEl.value === text)
			{
				return;
			}

			text = textareaEl.value;
			s9e.TextFormatter.preview(text, previewEl);
		}, 20);

		function toggle(el)
		{
			(el.checked) ? s9e.TextFormatter.enablePlugin(el.id)
			             : s9e.TextFormatter.disablePlugin(el.id);

			text = '';
		}
	</script>
	<script type="text/javascript" src="http://cdnjs.cloudflare.com/ajax/libs/punycode/1.0.0/punycode.min.js"></script>
</body>
</html>